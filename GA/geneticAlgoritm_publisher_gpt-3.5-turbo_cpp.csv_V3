generation,prompt,code,fitness
0,ROS1 publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");
    
    // Create a node handle
    ros::NodeHandle nh;
    
    // Create a Publisher object
    ros::Publisher pub = nh.advertise<std_msgs::String>(""/chatter"", 10);
    
    // Set the loop rate to 1 Hz
    ros::Rate loop_rate(1);
    
    int count = 0;
    
    while (ros::ok())
    {
        // Create the message
        std_msgs::String msg;
        msg.data = ""Hello, ROS! "" + std::to_string(count);
        
        // Publish the message
        pub.publish(msg);
        
        // Output to console
        ROS_INFO(""%s"", msg.data.c_str());
        
        // Spin once
        ros::spinOnce();
        
        // Sleep to maintain the 1 Hz rate
        loop_rate.sleep();
        
        count++;
    }
    
    return 0;
}",9.139437115379645
0,code ROS pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""publisher_node"");
    ros::NodeHandle nh;

    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);
    ros::Rate loop_rate(10);

    int count = 0;
    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = ""Hello, world! "" + std::to_string(count);

        ROS_INFO(""Publishing: %s"", msg.data.c_str());

        chatter_pub.publish(msg);
        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",9.210647293640527
1,launch code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""number_publisher"");
    ros::NodeHandle nh;

    // Create a publisher object
    ros::Publisher number_pub = nh.advertise<std_msgs::Int32>(""random_number"", 10);

    // Set the loop rate (in Hz)
    ros::Rate loop_rate(1);

    while (ros::ok()) {
        // Create a message object
        std_msgs::Int32 msg;

        // Generate a random number (between 1 and 100)
        msg.data = rand() % 100 + 1;

        // Publish the message
        number_pub.publish(msg);

        // Log to console
        ROS_INFO(""Publishing: %d"", msg.data);

        // Spin once to let the callback function to be called
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",9.143313903683403
2,code ROS pub cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");
    ros::NodeHandle nh;

    // Create a publisher that publishes messages of type std_msgs::String on the 'chatter' topic
    ros::Publisher pub = nh.advertise<std_msgs::String>(""chatter"", 10);
    
    // Set the publishing rate (in Hz)
    ros::Rate loop_rate(1); // 1 Hz

    int count = 0;
    
    while (ros::ok()) {
        // Create a string message
        std_msgs::String msg;
        msg.data = ""Hello, ROS! "" + std::to_string(count);
        
        // Publish the message
        pub.publish(msg);
        
        ROS_INFO(""Published message: %s"", msg.data.c_str());
        
        ros::spinOnce();
        
        loop_rate.sleep();
        
        count++;
    }
    
    return 0;
}",9.14747253308537
22,code parameter code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    ros::Publisher pub = nh.advertise<std_msgs::String>(""parameter_topic"", 10);

    ros::Rate loop_rate(1); // 1 Hz

    std_msgs::String msg;
    msg.data = ""Hello, ROS!"";

    while (ros::ok()) {
        // Publish the message
        pub.publish(msg);

        // Log the message
        ROS_INFO(""Published: %s"", msg.data.c_str());

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.21354553406085
23,code parameter cpp,"#include <ros/ros.h>

// Callback function for subscriber
void messageCallback(const std_msgs::String::ConstPtr& msg) {
    ROS_INFO(""Received message: %s"", msg->data.c_str());
}

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""listener_node"");
    
    // Create a node handle
    ros::NodeHandle nh;
    
    // Subscribe to the ""chatter"" topic
    ros::Subscriber sub = nh.subscribe(""chatter"", 1000, messageCallback);
    
    // Spin to keep the node running
    ros::spin();
    
    return 0;
}",0
24,code parameter code cpp with topic chatter,"// Include necessary ROS libraries
#include ""ros/ros.h""
#include ""std_msgs/String.h""

// Callback function to handle incoming messages on the ""chatter"" topic
void chatterCallback(const std_msgs::String::ConstPtr& msg) {
    ROS_INFO(""Received message: [%s]"", msg->data.c_str());
}

int main(int argc, char **argv) {
    // Initialize the ROS node with a unique name
    ros::init(argc, argv, ""listener"");

    // Create a NodeHandle for this node
    ros::NodeHandle nh;

    // Subscribe to the ""chatter"" topic with a queue size of 1000 and specify the callback function
    ros::Subscriber sub = nh.subscribe(""chatter"", 1000, chatterCallback);

    // Spin to listen for incoming messages
    ros::spin();

    return 0;
}",3.7123367609388853
25,code parameter code publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterPublisher:
    def __init__(self):
        rospy.init_node('parameter_publisher', anonymous=True)
        self.chatter_pub = rospy.Publisher('chatter', String, queue_size=10)
        self.rate = rospy.Rate(1)  # 1 Hz

    def publish_parameter(self):
        parameter_value = rospy.get_param('~parameter_name', 'default_value')

        while not rospy.is_shutdown():
            self.chatter_pub.publish(parameter_value)
            self.rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher = ParameterPublisher()
        parameter_publisher.publish_parameter()
    except rospy.ROSInterruptException:
        pass",0
29,code parameter pub cpp with topic data chatter,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv)
{
    ros::init(argc, argv, ""parameter_pub"");
    ros::NodeHandle nh;

    // Read the parameter from the ROS parameter server
    int param_value;
    nh.param(""param_value"", param_value, 10);

    // Create a publisher for publishing data to the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::Int32>(""chatter"", 10);

    ros::Rate loop_rate(1); // Publish at a rate of 1 Hz

    while (ros::ok())
    {
        std_msgs::Int32 msg;
        msg.data = param_value;

        ROS_INFO(""Publishing: %d"", msg.data);
        
        // Publish the message
        chatter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.90908598475352
33,code message ROS pub cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");
    ros::NodeHandle nh;

    // Create a Publisher object with topic name ""custom_topic"" and queue size of 10
    ros::Publisher pub = nh.advertise<std_msgs::String>(""custom_topic"", 10);

    // Publish a message every 1 second
    ros::Rate loop_rate(1);

    while (ros::ok()) {
        // Create a message
        std_msgs::String msg;
        msg.data = ""Hello, ROS!"";

        // Publish the message
        pub.publish(msg);

        // Log the message to the console
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Wait for the next iteration
        loop_rate.sleep();
    }

    return 0;
}",8.913760182650073
34,code ROS data pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""data_pub"");
    ros::NodeHandle nh;

    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""/chatter"", 10);
    ros::Rate loop_rate(10);

    int count = 0;
    
    while (ros::ok()) {
        std_msgs::String msg;
        std::stringstream ss;
        ss << ""Hello, world! "" << count;
        msg.data = ss.str();

        ROS_INFO(""Publishing: %s"", msg.data.c_str());
        chatter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",9.200118369602718
36,code parameter pub cpp with subject chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node with a unique name
    ros::init(argc, argv, ""parameter_pub_node"");

    // Create a node handle to communicate with the ROS system
    ros::NodeHandle nh;

    // Create a publisher for the 'chatter' topic with a queue size of 10
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate to 1 Hz
    ros::Rate loop_rate(1);

    while(ros::ok()) {
        // Create a string message
        std_msgs::String msg;
        msg.data = ""Hello, ROS!"";

        // Publish the message
        chatter_pub.publish(msg);

        // Log the message to the console
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Spin once to process callbacks
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.8848221005159
37,code parameter pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_pub"");
    ros::NodeHandle nh;

    // Define the topic name
    std::string topic_name = ""chatter"";

    // Create a publisher for the ""chatter"" topic
    ros::Publisher pub = nh.advertise<std_msgs::String>(topic_name, 10);

    // Set the publishing rate
    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        // Create a message
        std_msgs::String msg;
        msg.data = ""Hello, world!"";

        // Publish the message
        pub.publish(msg);

        // Spin once and sleep accordingly
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.920810519722673
43,code parameter ROS pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a Publisher object to publish messages on the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the publishing frequency
    ros::Rate loop_rate(1); // 1 Hz

    // Initialize message counter
    int count = 0;

    while (ros::ok())
    {
        // Create a message object
        std_msgs::String msg;
        msg.data = ""Hello, world! Count: "" + std::to_string(count);

        // Publish the message
        chatter_pub.publish(msg);

        // Print the published message
        ROS_INFO(""%s"", msg.data.c_str());

        // Increment the count
        count++;

        // Spin once to process callback functions
        ros::spinOnce();

        // Sleep for the remaining time to keep the publishing frequency
        loop_rate.sleep();
    }

    return 0;
}",8.867768226384921
46,code message ROS pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""publisher_node"");
    ros::NodeHandle node;

    ros::Publisher chatter_pub = node.advertise<std_msgs::String>(""chatter"", 1000);
    ros::Rate loop_rate(1); // Publish at 1Hz

    int count = 0;
    while (ros::ok()) {
        std_msgs::String msg;
        std::stringstream ss;
        ss << ""Hello, ROS! "" << count;
        msg.data = ss.str();

        ROS_INFO(""Publishing: %s"", msg.data.c_str());
        chatter_pub.publish(msg);
        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",9.19385606113493
50,code variable code cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
  ROS_INFO(""I heard: [%s]"", msg->data.c_str());
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, ""listener"");
  ros::NodeHandle n;
  
  ros::Subscriber sub = n.subscribe(""chatter"", 1000, chatterCallback);

  ros::spin();

  return 0;
}",4.520852867516159
51,code factor pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher that publishes messages of type std_msgs::String on the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate
    ros::Rate loop_rate(10); // 10 Hz

    int count = 0;

    while (ros::ok()) {
        // Create a string message
        std_msgs::String msg;
        msg.data = ""Hello, world! "" + std::to_string(count);

        // Publish the message
        chatter_pub.publish(msg);

        // Log the message to the console
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Spin once to process callbacks
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();

        count++;
    }

    return 0;
}",9.13102422067468
54,code parameter code parameter cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

// Callback function to handle messages on the chatter topic
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
  ROS_INFO(""I heard: [%s]"", msg->data.c_str());
}

int main(int argc, char **argv)
{
  // Initialize the ROS node
  ros::init(argc, argv, ""listener"");

  // Create a NodeHandle to communicate with the ROS system
  ros::NodeHandle nh;

  // Subscribe to the ""chatter"" topic with a queue size of 10 and specify the callback function
  ros::Subscriber sub = nh.subscribe(""chatter"", 10, chatterCallback);

  // Spin to wait for incoming messages
  ros::spin();

  return 0;
}",3.978422586006208
66,code ROS pub cpp execution with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize ROS node with a unique name
    ros::init(argc, argv, ""publisher_node"");

    // Create a handle to the ROS Node
    ros::NodeHandle node_handle;

    // Create a publisher object to publish messages on the chatter topic
    ros::Publisher chatter_pub = node_handle.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate for publishing messages
    ros::Rate loop_rate(1); // 1 Hz

    int count = 0;
    while (ros::ok())
    {
        // Create a message object
        std_msgs::String msg;
        msg.data = ""Hello, world! "" + std::to_string(count);

        // Publish the message
        chatter_pub.publish(msg);

        ROS_INFO(""Message sent: %s"", msg.data.c_str());

        // Spin once to handle callbacks
        ros::spinOnce();

        // Sleep for the remaining time to meet the desired loop rate
        loop_rate.sleep();

        count++;
    }

    return 0;
}",8.724952503857846
68,code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

void messageCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO(""Received message: %s"", msg->data.c_str());
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, ""message_subscriber"");
    ros::NodeHandle node;

    ros::Subscriber sub = node.subscribe(""chatter"", 1000, messageCallback);

    ros::spin(); // Keeps the node running until ROS shutdown

    return 0;
}",4.521427603198557
72,code parameter ROS pub cpp with chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");
    ros::NodeHandle nh;

    // Create a publisher for the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate for the publisher
    ros::Rate loop_rate(10); // 10Hz

    // Main loop to publish messages
    while (ros::ok())
    {
        // Create a message object
        std_msgs::String msg;
        msg.data = ""Hello, world!"";

        // Publish the message
        chatter_pub.publish(msg);

        // Process callback functions
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.765876223385263
73,task code parameter code with topic chatter,"#!/usr/bin/env python

# Import necessary ROS packages
import rospy
from std_msgs.msg import String

def chatter_callback(msg):
    """"""
    Callback function to process incoming messages on the 'chatter' topic.
    """"""
    rospy.loginfo(""Received: %s"", msg.data)

def chatter_listener():
    """"""
    Initialize the ROS node and subscribe to the 'chatter' topic.
    """"""
    # Initialize the ROS node with the name 'chatter_listener'
    rospy.init_node('chatter_listener', anonymous=True)

    # Subscribe to the 'chatter' topic with a callback function
    rospy.Subscriber('chatter', String, chatter_callback)

    # Spin to prevent the node from exiting
    rospy.spin()

if __name__ == '__main__':
    try:
        chatter_listener()
    except rospy.ROSInterruptException:
        pass",0
76,parameter code publisher with topic chatter,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    ros::Publisher chatter_pub = nh.advertise<std_msgs::Int32>(""/chatter"", 10);

    ros::Rate loop_rate(1); // 1 Hz

    // Main loop to publish the parameter
    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = 42; // Set the parameter value here

        chatter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.215982692418306
77,parameter code code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Declare a parameter for the publisher
    std::string topic_name;
    nh.param<std::string>(""/parameter_publisher/topic_name"", topic_name, ""parameter_topic"");

    ros::Publisher pub = nh.advertise<std_msgs::Int32>(topic_name, 10);
    ros::Rate loop_rate(1); // 1 Hz

    int count = 0;
    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = count;

        pub.publish(msg);
        ROS_INFO(""Published: %d"", msg.data);

        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",8.927127889802437
78,parameter code publisher publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle n;

    // Create a publisher for publishing a parameter
    ros::Publisher parameter_pub = n.advertise<std_msgs::String>(""parameter_topic"", 10);

    // Set the frequency for publishing the parameter
    ros::Rate loop_rate(1); // 1 Hz

    // Main loop for publishing the parameter
    while (ros::ok())
    {
        std_msgs::String msg;
        msg.data = ""your_parameter_value_here""; // Set the parameter value here

        // Publish the parameter
        parameter_pub.publish(msg);

        // Log the published parameter
        ROS_INFO(""Published Parameter: %s"", msg.data.c_str());

        // Sleep to maintain the frequency
        loop_rate.sleep();
    }

    return 0;
}",8.643286898615868
79,parameter parameter code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Float32.h>

class ParameterPublisher {
public:
    ParameterPublisher() {
        nh.getParam(""/my_parameter"", my_parameter);
        if (my_parameter <= 0.0) {
            ROS_WARN(""Invalid parameter value, setting it to default (1.0)"");
            my_parameter = 1.0;
        }

        pub = nh.advertise<std_msgs::Float32>(""parameter_topic"", 10);
    }

    void publishParameter() {
        std_msgs::Float32 msg;
        msg.data = my_parameter;
        pub.publish(msg);
    }

private:
    ros::NodeHandle nh;
    ros::Publisher pub;
    float my_parameter;
};

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    
    ParameterPublisher parameter_publisher;

    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        parameter_publisher.publishParameter();
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.881445040164573
81,component code publisher with system cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher that publishes messages of type std_msgs::String on the topic ""chatter""
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate (in Hz)
    ros::Rate loop_rate(1); // 1Hz, message publishing rate

    int count = 0;

    while (ros::ok())
    {
        // Create a message object
        std_msgs::String msg;
        std::stringstream ss;
        ss << ""Hello ROS! "" << count;
        msg.data = ss.str();

        // Publish the message
        chatter_pub.publish(msg);

        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Process callbacks
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
        count++;
    }

    return 0;
}",9.126488482808501
84,parameter code publisher with topic topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_publisher():
    rospy.init_node('parameter_publisher', anonymous=True)
    rate = rospy.Rate(1)  # 1 Hz

    # Get parameter value from ROS parameter server
    param_value = rospy.get_param('~param_value', 'default_value')

    pub = rospy.Publisher('topic_chatter', String, queue_size=10)

    while not rospy.is_shutdown():
        msg = String()
        msg.data = param_value
        rospy.loginfo(""Publishing: {}"".format(msg.data))
        pub.publish(msg)
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher()
    except rospy.ROSInterruptException:
        pass",0
85,parameter code publisher with cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Create a publisher with topic ""chatter"" that publishes std_msgs/String messages
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    ros::Rate loop_rate(1); // Publisher frequency in Hz

    while (ros::ok())
    {
        std_msgs::String msg;
        msg.data = ""Hello, ROS!"";

        ROS_INFO(""Publishing: %s"", msg.data.c_str());

        // Publish the message
        chatter_pub.publish(msg);

        ros::spinOnce();

        loop_rate.sleep();
    }

    return 0;
}",9.175060931155755
86,parameter code publisher with system cpp,"#include ""ros/ros.h""
#include ""std_msgs/Float64.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");

    // Create a NodeHandle for communication with the ROS system
    ros::NodeHandle nh;

    // Create a publisher with topic ""parameter_topic"" that sends Float64 messages
    ros::Publisher parameter_pub = nh.advertise<std_msgs::Float64>(""parameter_topic"", 10);

    // Set the loop rate (in Hz)
    ros::Rate loop_rate(1); // 1 Hz

    // Main loop
    while (ros::ok()) {
        // Create a Float64 message
        std_msgs::Float64 msg;
        // Set a sample parameter value
        msg.data = 42.0;

        // Publish the message
        parameter_pub.publish(msg);

        // Log the published parameter value
        ROS_INFO(""Published parameter value: %.2f"", msg.data);

        // Spin once to process callbacks
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.870936734577615
87,parameter code publisher with cpp,"#include <ros/ros.h>

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle nh;

    // Define parameters
    int parameter_int = 42;
    double parameter_double = 3.14;
    std::string parameter_string = ""Hello, ROS!"";

    // Publish parameters to the ROS parameter server
    nh.setParam(""/my_parameters/integer_param"", parameter_int);
    nh.setParam(""/my_parameters/double_param"", parameter_double);
    nh.setParam(""/my_parameters/string_param"", parameter_string);

    ROS_INFO(""Parameters published to the parameter server"");

    // Spin and provide callbacks
    ros::spin();

    return 0;
}",4.470444733142982
92,parameter interface code publisher publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

class ParameterInterface
{
public:
    ParameterInterface()
    {
        // Initialize ROS node handle
        nh_ = ros::NodeHandle(""~"");

        // Get parameters
        nh_.param<std::string>(""message"", message_, ""Hello World!"");

        // Create publisher
        pub_ = nh_.advertise<std_msgs::String>(""message_topic"", 10);
    }

    void run()
    {
        // ROS loop rate
        ros::Rate loop_rate(1); // 1Hz

        while (ros::ok())
        {
            // Publish message
            std_msgs::String msg;
            msg.data = message_;
            pub_.publish(msg);

            ros::spinOnce();
            loop_rate.sleep();
        }
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    std::string message_;
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, ""parameter_interface_publisher"");

    ParameterInterface parameterInterface;
    parameterInterface.run();

    return 0;
}",9.12545070778022
93,parameter code publisher with execution cpp,"#include ""ros/ros.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle nh;

    // Set the parameter value
    nh.setParam(""/my_parameter"", 42);

    // Publisher loop rate (1 Hz)
    ros::Rate loop_rate(1);
    
    while (ros::ok()) {
        // Publish the parameter value
        int parameter_value;
        nh.getParam(""/my_parameter"", parameter_value);
        ROS_INFO(""Publishing parameter: %d"", parameter_value);
        
        // Sleep to match the loop rate
        loop_rate.sleep();
    }

    return 0;
}",3.9989827221847993
97,parameter parameter sensor code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Float32.h>

class SensorPublisher {
public:
    SensorPublisher(ros::NodeHandle nh, double update_rate) : nh_(nh), update_rate_(update_rate) {
        sensor_data_pub_ = nh_.advertise<std_msgs::Float32>(""sensor_data"", 10);
        sensor_value_ = 0.0;
    }

    void startPublishing() {
        ros::Rate loop_rate(update_rate_);

        while (ros::ok()) {
            std_msgs::Float32 msg;
            msg.data = readSensorData(); // Read sensor data here
            sensor_data_pub_.publish(msg);
            ros::spinOnce();
            loop_rate.sleep();
        }
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher sensor_data_pub_;
    double update_rate_;
    double sensor_value_;

    double readSensorData() {
        // Placeholder function for reading sensor data
        // Replace this with your actual sensor reading code
        sensor_value_ += 0.1;
        return sensor_value_;
    }
};

int main(int argc, char** argv) {
    ros::init(argc, argv, ""sensor_publisher"");
    ros::NodeHandle nh;

    double update_rate = 10.0; // Hz
    SensorPublisher sensor_publisher(nh, update_rate);

    sensor_publisher.startPublishing();

    ros::shutdown();
    return 0;
}",8.696004981279453
98,parameter code publisher task cpp,"#include <ros/ros.h>
#include <std_msgs/Float64.h>

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle nh;

    // Parameter to be published
    double parameter_value = 0.0;
    nh.param(""parameter_value"", parameter_value, 0.0);

    // Publisher for the parameter
    ros::Publisher parameter_pub = nh.advertise<std_msgs::Float64>(""parameter_topic"", 10);

    // Set the loop rate
    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        // Create a message and set the parameter value
        std_msgs::Float64 parameter_msg;
        parameter_msg.data = parameter_value;

        // Publish the parameter value
        parameter_pub.publish(parameter_msg);

        // Log the published value
        ROS_INFO(""Published parameter value: %.2f"", parameter_msg.data);

        // Spin once and sleep
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.876915088726953
104,code code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher with topic name ""chatter"" that publishes std_msgs::String messages
    ros::Publisher pub = nh.advertise<std_msgs::String>(""chatter"", 1000);

    // Set the loop rate for publishing messages (in Hz)
    ros::Rate loop_rate(1); // 1 Hz

    int count = 0;
    while (ros::ok()) {
        // Create a message
        std_msgs::String msg;
        msg.data = ""Hello, world! "" + std::to_string(count);

        // Publish the message
        pub.publish(msg);

        // Log the message for debugging
        ROS_INFO(""%s"", msg.data.c_str());

        // Spin once to let the ROS run callbacks
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();

        count++;
    }

    return 0;
}",8.730294231541658
111,variable code code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");
    ros::NodeHandle node;

    // Create a publisher for the ""chatter"" topic with a queue size of 10
    ros::Publisher chatter_pub = node.advertise<std_msgs::String>(""chatter"", 10);

    // Set the publishing rate to 1 Hz
    ros::Rate loop_rate(1);

    int count = 0;
    while (ros::ok()) {
        // Create a message object
        std_msgs::String msg;
        std::stringstream ss;
        ss << ""Hello, ROS! "" << count;
        msg.data = ss.str();

        // Publish the message
        chatter_pub.publish(msg);

        // Print the message to the console
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Spin once to process callback functions
        ros::spinOnce();

        // Sleep to maintain the publishing rate
        loop_rate.sleep();
        count++;
    }

    return 0;
}",8.879126235550649
115,variable code publisher with cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node with a unique name
    ros::init(argc, argv, ""publisher_node"");
    
    // Create a node handle to communicate with the ROS system
    ros::NodeHandle nh;
    
    // Create a publisher object to publish messages of type std_msgs/String on the ""topic_name"" topic
    ros::Publisher pub = nh.advertise<std_msgs::String>(""topic_name"", 10);
    
    // Set the publishing rate to 1 Hz
    ros::Rate loop_rate(1);
    
    int count = 0;
    while (ros::ok()) {
        // Create a message object
        std_msgs::String msg;
        
        // Fill the message with data
        msg.data = ""Hello, world! "" + std::to_string(count);
        
        // Publish the message
        pub.publish(msg);
        
        // Log the published message
        ROS_INFO(""Published: %s"", msg.data.c_str());
        
        // Spin once to process callbacks
        ros::spinOnce();
        
        // Sleep to maintain the publishing rate
        loop_rate.sleep();
        
        count++;
    }
    
    return 0;
}",9.109175188332495
116,parameter parameter ROS pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        // Create a message
        std_msgs::String msg;
        msg.data = ""Hello, world!"";

        // Publish the message
        chatter_pub.publish(msg);

        // Spin once
        ros::spinOnce();

        // Sleep for the rest of the cycle to meet the specified rate
        loop_rate.sleep();
    }

    return 0;
}",8.953041190512417
117,parameter code publisher cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Create a publisher for the 'chatter' topic with a queue size of 10
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Define the loop rate (e.g., 1 Hz)
    ros::Rate loop_rate(1);

    while (ros::ok()) {
        // Create a message object
        std_msgs::String msg;

        // Set the message data
        msg.data = ""Hello, ROS!"";

        // Publish the message
        chatter_pub.publish(msg);

        // Log a message
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Spin once to let ROS process incoming messages
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.892532789230778
129,factor parameter code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""factor_publisher"");
    ros::NodeHandle nh;

    // Create a publisher for publishing factor parameter
    ros::Publisher factor_pub = nh.advertise<std_msgs::Int32>(""factor"", 10);

    // Define the factor parameter and load it from the parameter server
    int factor;
    if (!nh.getParam(""factor"", factor))
    {
        ROS_ERROR(""Failed to get parameter 'factor'"");
        return 1;
    }

    // Create a message object
    std_msgs::Int32 factor_msg;
    factor_msg.data = factor;

    // Publish the factor parameter
    ros::Rate loop_rate(1);  // 1 Hz
    while (ros::ok())
    {
        factor_pub.publish(factor_msg);
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",3.4455630502271215
131,parameter code mapping publisher with cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Create a publisher for the parameter map
    ros::Publisher pub = nh.advertise<std_msgs::String>(""parameter_map"", 10);

    ros::Rate loop_rate(1); // Publish at 1 Hz

    while (ros::ok()) {
        // Retrieve the parameter map
        const ros::NodeHandle nh_priv(""~"");
        std::map<std::string, std::string> params;
        nh_priv.getParamNames(params);

        // Create a string for the key-value pairs
        std::stringstream ss;
        for (const auto& param : params) {
            ss << param.first << "": "" << param.second << ""; "";
        }

        // Create a message and publish the parameter map
        std_msgs::String msg;
        msg.data = ss.str();
        pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",0
134,parameter code parameter code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterNode:
    def __init__(self):
        rospy.init_node('chatter_node', anonymous=True)
        self.rate = rospy.Rate(1)  # 1 Hz
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        self.param_value = rospy.get_param('~my_param', 'default_value')

    def publish_message(self):
        msg = String()
        msg.data = ""Parameter value: {}"".format(self.param_value)
        rospy.loginfo(msg.data)
        self.pub.publish(msg)

    def run(self):
        while not rospy.is_shutdown():
            self.publish_message()
            self.rate.sleep()

if __name__ == '__main__':
    try:
        chatter_node = ChatterNode()
        chatter_node.run()
    except rospy.ROSInterruptException:
        pass",0
135,parameter code publisher interface publisher node cpp,"#include <ros/ros.h>

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_node"");
    ros::NodeHandle nh;

    // Set a parameter on the Parameter Server
    nh.setParam(""/my_parameter"", 42);

    // Get a parameter from the Parameter Server
    int param_value;
    if (nh.getParam(""/my_parameter"", param_value)) {
        ROS_INFO(""Retrieved parameter: %d"", param_value);
    } else {
        ROS_ERROR(""Failed to retrieve parameter"");
    }

    ros::spin();

    return 0;
}",3.7702418475379957
136,parameter code message publisher with cpp,"#include ""ros/ros.h""
#include ""your_custom_message_package/YourCustomMessage.h""

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_message_publisher"");
    ros::NodeHandle nh;

    // Create a publisher for your custom message with parameters
    ros::Publisher pub = nh.advertise<your_custom_message_package::YourCustomMessage>(""custom_message_topic"", 10);

    // Set the parameters for the custom message
    double parameter1 = 0.5;
    int parameter2 = 10;
    std::string parameter3 = ""Hello, ROS!"";

    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        // Create an instance of your custom message and fill in the parameters
        your_custom_message_package::YourCustomMessage msg;
        msg.parameter1 = parameter1;
        msg.parameter2 = parameter2;
        msg.parameter3 = parameter3;

        // Publish the message
        pub.publish(msg);

        // Log the published message
        ROS_INFO(""Published custom message: parameter1=%f, parameter2=%d, parameter3=%s"", msg.parameter1, msg.parameter2, msg.parameter3.c_str());

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",0
142,factor code code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/String.h>

class FactorPublisher
{
public:
    FactorPublisher()
    {
        // Initialize ROS node handle
        nh = ros::NodeHandle();

        // Create a publisher for 'factor' topic
        factor_pub = nh.advertise<std_msgs::String>(""factor"", 10);

        // Publish factors of numbers from 1 to 10
        publishFactors(1, 10);
    }

    void publishFactors(int start, int end)
    {
        std_msgs::String msg;

        for (int i = start; i <= end; i++)
        {
            std::stringstream factors;
            factors << ""Factors of "" << i << "": "";

            for (int j = 1; j <= i; j++)
            {
                if (i % j == 0)
                {
                    factors << j << "" "";
                }
            }

            msg.data = factors.str();
            factor_pub.publish(msg);

            ros::Duration(0.5).sleep(); // Delay for better visualization
        }
    }

private:
    ros::NodeHandle nh;
    ros::Publisher factor_pub;
};

int main(int argc, char **argv)
{
    // Initialize ROS node
    ros::init(argc, argv, ""factor_publisher"");

    // Create an instance of FactorPublisher
    FactorPublisher factorPublisher;

    // Spin to handle callbacks
    ros::spin();

    return 0;
}",8.520189605435247
145,parameter code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher"");

    // Create a NodeHandle
    ros::NodeHandle nh;

    // Create a publisher for publishing a parameter value
    ros::Publisher parameter_pub = nh.advertise<std_msgs::Int32>(""parameter_topic"", 10);

    // Define the loop rate
    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        // Create a message to publish
        std_msgs::Int32 msg;
        // Set the parameter value
        msg.data = 42;

        // Publish the message
        parameter_pub.publish(msg);

        // Display message in the console
        ROS_INFO(""Published parameter value: %d"", msg.data);

        // Spin once to handle callbacks
        ros::spinOnce();

        // Sleep for the remaining time to keep loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.734337245368563
147,factor variable code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

// Factorial function
int factorial(int n) {
    if (n == 0)
        return 1;
    else
        return n * factorial(n - 1);
}

int main(int argc, char **argv) {
    ros::init(argc, argv, ""factorial_publisher"");
    ros::NodeHandle nh;

    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""/factorial"", 10);

    ros::Rate rate(10); // 10Hz

    while (ros::ok()) {
        int num;
        std::cout << ""Enter a number to calculate factorial: "";
        std::cin >> num;

        std_msgs::Int32 msg;
        msg.data = factorial(num);

        pub.publish(msg);

        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}",3.405724110110944
151,interface parameter code publisher publisher cpp,"#include <ros/ros.h>
#include <std_msgs/String.h>

class ParameterCodePublisher
{
public:
    ParameterCodePublisher()
    {
        // Initialize ROS node handle
        nh_ = ros::NodeHandle();

        // Get ROS params
        nh_.param<std::string>(""/parameter_code"", parameter_code_, ""default_value"");

        // Setup publisher
        pub_ = nh_.advertise<std_msgs::String>(""parameter_code_topic"", 10);
    }

    void publishParameterCode()
    {
        std_msgs::String msg;
        msg.data = parameter_code_;

        // Publish parameter code
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    std::string parameter_code_;
};

int main(int argc, char** argv)
{
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_code_publisher"");

    // Create ParameterCodePublisher object
    ParameterCodePublisher parameter_code_publisher;

    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok())
    {
        parameter_code_publisher.publishParameterCode();

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.10947905292795
162,component code publisher cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher with topic ""chatter"" that publishes String messages
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate (in Hz)
    ros::Rate loop_rate(1);  // Publish at 1 Hz

    int count = 0;
    while (ros::ok())
    {
        // Create a message to be published
        std_msgs::String msg;
        msg.data = ""Hello World "" + std::to_string(count);

        // Publish the message
        chatter_pub.publish(msg);

        // Log the published message
        ROS_INFO(""Published: %s"", msg.data.c_str());

        ros::spinOnce();

        loop_rate.sleep();

        count++;
    }

    return 0;
}",9.142379298585436
163,parameter code publisher with spin system cpp,"#include ""ros/ros.h""
#include ""std_msgs/Float64.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Define a parameter for publishing
    double parameter_value = 0.0;
    nh.param(""parameter_value"", parameter_value, 0.0); // If parameter not set, default to 0.0

    ros::Publisher parameter_pub = nh.advertise<std_msgs::Float64>(""parameter_topic"", 10);

    ros::Rate loop_rate(10);

    while (ros::ok()) {
        std_msgs::Float64 msg;
        msg.data = parameter_value;

        parameter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.933267341440398
166,component parameter code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Define the publisher with a topic to publish to
    ros::Publisher pub = nh.advertise<std_msgs::String>(""parameter_topic"", 10);

    // Define a rate to control the publishing frequency
    ros::Rate rate(1); // 1 Hz

    // Main loop
    while (ros::ok())
    {
        // Get the parameter value from the parameter server
        std::string parameter_value;
        if (!nh.getParam(""/my_parameter"", parameter_value)) {
            ROS_ERROR(""Failed to get parameter '/my_parameter'"");
        }

        // Create a message
        std_msgs::String msg;
        msg.data = parameter_value;

        // Publish the message
        pub.publish(msg);

        // Spin once
        ros::spinOnce();

        // Sleep to control the publishing rate
        rate.sleep();
    }

    return 0;
}",8.87560401649436
172,parameter publisher publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

class ParameterPublisher {
public:
    ParameterPublisher() {
        // Initialize ROS node handle
        nh_ = ros::NodeHandle();

        // Initialize parameter
        nh_.param<int>(""my_parameter"", parameter_, 0);

        // Initialize publisher
        pub_ = nh_.advertise<std_msgs::Int32>(""parameter"", 10);
    }

    void publishParameter() {
        std_msgs::Int32 msg;
        msg.data = parameter_;
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    int parameter_;
};

int main(int argc, char** argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");

    // Create ParameterPublisher object
    ParameterPublisher parameter_publisher;

    // Specify the publish rate
    ros::Rate loop_rate(1); // 1 Hz

    // Main loop
    while (ros::ok()) {
        parameter_publisher.publishParameter();
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.119062831567701
176,parameter code sensor code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Float32.h""

// Define a class for the sensor node
class SensorNode {
public:
    SensorNode() {
        // Initialize node handle
        nh = ros::NodeHandle();

        // Create publisher to publish sensor data
        sensor_pub = nh.advertise<std_msgs::Float32>(""sensor_data"", 10);

        // Set update rate for publishing sensor data (in Hz)
        update_rate = 10; // Publish sensor data at 10 Hz
        ros::Rate loop_rate(update_rate);
    }

    // Function to publish sensor data
    void publishSensorData(float sensor_value) {
        std_msgs::Float32 msg;
        msg.data = sensor_value;
        sensor_pub.publish(msg);
        ros::spinOnce();
    }

private:
    ros::NodeHandle nh;
    ros::Publisher sensor_pub;
    int update_rate;
};

int main(int argc, char **argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""sensor_node"");

    // Create an instance of SensorNode
    SensorNode sensor_node;

    // Simulate sensor data
    float sensor_data = 0.0;

    ros::Rate loop_rate(sensor_node.update_rate);
    while (ros::ok()) {
        sensor_node.publishSensorData(sensor_data);

        // Update sensor data
        sensor_data += 0.1;

        loop_rate.sleep();
    }

    return 0;
}",0
180,variable code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher for the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the publishing frequency to 1Hz
    ros::Rate loop_rate(1);

    // Main loop
    while (ros::ok()) {
        // Create a string message
        std_msgs::String msg;
        msg.data = ""Hello, ROS!"";

        // Publish the message
        chatter_pub.publish(msg);

        // Spin once to process callbacks
        ros::spinOnce();

        // Sleep to maintain 1Hz publishing frequency
        loop_rate.sleep();
    }

    return 0;
}",8.909369438343367
185,code publisher publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher object
    ros::Publisher pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the publishing rate
    ros::Rate rate(1); // 1 Hz

    while (ros::ok()) {
        // Create a message
        std_msgs::String msg;
        msg.data = ""Hello, World!"";

        // Publish the message
        pub.publish(msg);

        // Output log message
        ROS_INFO(""Message published: %s"", msg.data.c_str());

        // Spin once
        ros::spinOnce();

        // Sleep to maintain the publishing rate
        rate.sleep();
    }

    return 0;
}",9.15926283460656
189,parameter code publisher mapping with cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

class ParameterPublisherNode {
public:
    ParameterPublisherNode(ros::NodeHandle nh) : nh_(nh) {
        // Load parameters
        nh.getParam(""topic_name"", topic_name_);
        nh.getParam(""message"", message_);

        // Initialize the publisher
        pub_ = nh.advertise<std_msgs::String>(topic_name_, 10);

        // Publish the message at a fixed rate
        timer_ = nh.createTimer(ros::Duration(1.0), &ParameterPublisherNode::publishMessage, this);
    }

    void publishMessage(const ros::TimerEvent& event) {
        std_msgs::String msg;
        msg.data = message_;
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    ros::Timer timer_;

    std::string topic_name_;
    std::string message_;
};

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle nh;

    ParameterPublisherNode node(nh);

    ros::spin();

    return 0;
}",4.422267567088784
205,parameter code publisher with topic with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterPublisher:
    def __init__(self):
        rospy.init_node('parameter_publisher', anonymous=True)
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        self.rate = rospy.Rate(1)  # 1 Hz

    def publish_parameter(self):
        parameter_value = ""your_parameter_value""
        rospy.loginfo(""Publishing parameter: {}"".format(parameter_value))
        self.pub.publish(parameter_value)

    def run(self):
        while not rospy.is_shutdown():
            self.publish_parameter()
            self.rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher = ParameterPublisher()
        parameter_publisher.run()
    except rospy.ROSInterruptException:
        pass",0
210,parameter code publisher sensor publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Float32.h>

class SensorPublisher
{
public:
    SensorPublisher() : nh_(""~"")
    {
        nh_.param(""sensor_value"", sensor_value_, 0.0);
        sensor_data_pub_ = nh_.advertise<std_msgs::Float32>(""sensor_data"", 10);
    }

    void publishSensorData()
    {
        std_msgs::Float32 msg;
        msg.data = sensor_value_;
        sensor_data_pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher sensor_data_pub_;
    float sensor_value_;
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, ""sensor_publisher_node"");
    SensorPublisher sensor_pub;

    ros::Rate loop_rate(1); // Publishing rate of 1 Hz

    while (ros::ok())
    {
        sensor_pub.publishSensorData();
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",0
221,robot parameter code publisher with cpp,"#include <ros/ros.h>
#include <std_msgs/String.h>

int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""robot_parameter_publisher"");
    ros::NodeHandle nh;

    // Parameters - Modify these as per your robot specifications
    std::string robot_name = ""my_robot"";
    std::vector<std::string> joint_names = {""joint1"", ""joint2"", ""joint3""};
    std::vector<double> joint_dimensions = {0.1, 0.2, 0.3};

    // Publish robot parameters as ROS parameters
    nh.setParam(""/robot_name"", robot_name);
    nh.setParam(""/joint_names"", joint_names);
    nh.setParam(""/joint_dimensions"", joint_dimensions);

    ROS_INFO(""Robot parameters published: "");
    ROS_INFO(""Robot Name: %s"", robot_name.c_str());
    ROS_INFO(""Joint Names: "");
    for (const auto& joint : joint_names)
    {
        ROS_INFO(""  %s"", joint.c_str());
    }
    ROS_INFO(""Joint Dimensions: "");
    for (const auto& dimension : joint_dimensions)
    {
        ROS_INFO(""  %.2f"", dimension);
    }

    ros::spin();
    
    return 0;
}",3.6655599864730313
225,parameter code publisher with topic sensor cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""sensor_publisher"");
    ros::NodeHandle nh;

    ros::Publisher sensor_pub = nh.advertise<std_msgs::Int32>(""sensor_data"", 10);

    ros::Rate loop_rate(1); // Publish at 1Hz

    int sensor_data = 0;

    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = sensor_data;

        ROS_INFO(""Sensor data: %d"", msg.data);

        sensor_pub.publish(msg);

        sensor_data++;

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.205845149487757
228,parameter factor code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Float64.h""

class ParameterFactorPublisher {
public:
    ParameterFactorPublisher() {
        // Initialize the ROS node handle
        nh = ros::NodeHandle(""~"");

        // Get the parameter value from the parameter server
        nh.param<double>(""factor"", factor, 1.0);

        // Create a publisher for the factor
        factor_pub = nh.advertise<std_msgs::Float64>(""factor_topic"", 10);
    }

    void publishFactor() {
        // Publish the factor value on the topic
        std_msgs::Float64 factor_msg;
        factor_msg.data = factor;
        factor_pub.publish(factor_msg);
    }

private:
    ros::NodeHandle nh;
    ros::Publisher factor_pub;
    double factor;
};

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_factor_publisher"");

    ParameterFactorPublisher factor_publisher;

    // Set the loop rate for publishing
    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        factor_publisher.publishFactor();

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.707608041583367
231,parameter variable code mapping publisher task cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

// Define class for the ROS Node
class MappingPublisherNode {
public:
    MappingPublisherNode() {
        // Initialize node handle
        nh = ros::NodeHandle();

        // Initialize publisher
        pub = nh.advertise<std_msgs::String>(""mapped_task"", 10);

        // Define timer for publishing
        timer = nh.createTimer(ros::Duration(1.0), &MappingPublisherNode::publishMappedTask, this);
    }

    // Callback function for timer to publish mapped task
    void publishMappedTask(const ros::TimerEvent& event) {
        std_msgs::String msg;
        msg.data = ""Publishing mapped task"";

        // Publish the mapped task
        pub.publish(msg);
    }

private:
    ros::NodeHandle nh;
    ros::Publisher pub;
    ros::Timer timer;
};

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""mapping_publisher_node"");

    // Create an instance of the MappingPublisherNode class
    MappingPublisherNode mappingPublisherNode;

    // Spin to process callbacks
    ros::spin();

    return 0;
}",8.710635155883516
232,parameter code navigation publisher mapping with mapping cpp,"#include <ros/ros.h>
#include <nav_msgs/OccupancyGrid.h>

class MapPublisher {
public:
    MapPublisher() : nh(""~"") {
        map_pub = nh.advertise<nav_msgs::OccupancyGrid>(""/map"", 1);

        // Set up the map size and resolution
        map_info.width = 10;
        map_info.height = 10;
        map_info.resolution = 1.0;
        map_info.origin.position.x = -5.0;
        map_info.origin.position.y = -5.0;
        map_info.origin.position.z = 0.0;

        // Generate a fake map with obstacles
        map_data.resize(map_info.width * map_info.height, 0);
        map_data[5 * map_info.width + 5] = 100; // Add an obstacle at (5, 5)

        map.data = map_data;
        map.info = map_info;

        publishMap();
    }

    void publishMap() {
        map.header.stamp = ros::Time::now();
        map_pub.publish(map);
    }

private:
    ros::NodeHandle nh;
    ros::Publisher map_pub;
    nav_msgs::OccupancyGrid map;
    nav_msgs::MapMetaData map_info;
    std::vector<int8_t> map_data;
};

int main(int argc, char** argv) {
    ros::init(argc, argv, ""map_publisher_node"");

    MapPublisher mapPublisher;

    ros::spin();

    return 0;
}",4.40230084869786
233,parameter message parameter code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

// Define a ROS NodeHandle object
ros::NodeHandle nh;

// Define a Publisher object to publish Int32 messages on the 'parameter' topic
ros::Publisher pub = nh.advertise<std_msgs::Int32>(""parameter"", 10);

// Function to publish parameter messages
void publishParameterMessage(int parameter_value) {
    std_msgs::Int32 msg;
    msg.data = parameter_value;
    pub.publish(msg);
}

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher"");

    // Set the loop rate to publish messages at 1 Hz
    ros::Rate loop_rate(1);

    // Main loop
    while (ros::ok()) {
        // Publish a parameter message with value 42
        publishParameterMessage(42);

        // Spin once to handle callbacks
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",3.9342439722927076
236,parameter parameter pub cpp with topic data chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_pub"");
    ros::NodeHandle nh;

    // Define the parameter value to be published
    std::string parameter_value = ""Hello, ROS!"";

    // Publish the parameter on the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);
    ros::Rate loop_rate(10);

    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = parameter_value;

        // Publish the parameter
        chatter_pub.publish(msg);

        // Handle ROS communication events
        ros::spinOnce();

        loop_rate.sleep();
    }

    return 0;
}",9.172848300520535
239,variable code publisher publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""publisher_node"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher for publishing messages on the 'chatter' topic
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate to 1Hz
    ros::Rate loop_rate(1);

    int count = 0;
    while (ros::ok()) {
        // Create a message
        std_msgs::String msg;
        msg.data = ""Hello, ROS! "" + std::to_string(count);

        // Publish the message
        chatter_pub.publish(msg);

        // Log the published message
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Spin once to let ROS process the messages
        ros::spinOnce();

        // Sleep for the remaining time to keep the loop rate at 1Hz
        loop_rate.sleep();

        count++;
    }

    return 0;
}",8.729483133166893
240,parameter code publisher cpp with topic data chatter,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""data_chatter"", 10);

    ros::Rate rate(1); // 1 Hz

    int count = 0;
    
    // Set a parameter to be published
    nh.setParam(""my_parameter"", 42);

    while (ros::ok()) {
        std_msgs::Int32 msg;
        nh.getParam(""my_parameter"", msg.data);

        pub.publish(msg);
        ROS_INFO(""Publishing: %d"", msg.data);

        ros::spinOnce();
        rate.sleep();
        ++count;
    }

    return 0;
}",9.198697901137649
241,component code publisher planning with cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""planning_publisher"");
    ros::NodeHandle nh;

    // Create a publisher object for publishing planning data
    ros::Publisher planning_pub = nh.advertise<std_msgs::String>(""planning_topic"", 10);

    // Set the loop rate (e.g., 1 Hz)
    ros::Rate loop_rate(1);

    while (ros::ok()) {
        // Create a message object
        std_msgs::String msg;
        msg.data = ""Some planning data here""; // Populate the message with planning data

        // Publish the message
        planning_pub.publish(msg);

        // Log the published data
        ROS_INFO(""Planning data published: %s"", msg.data.c_str());

        // Spin once to process any incoming messages
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.883970309452872
246,parameter component code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Float32.h>

class ParameterComponent
{
public:
    ParameterComponent()
    {
        // Initialize ROS node handle
        nh_ = ros::NodeHandle(""~"");

        // Get parameter values
        nh_.getParam(""param1"", param1_);
        nh_.param(""param2"", param2_, 0.0);

        // Create publisher
        pub_ = nh_.advertise<std_msgs::Float32>(""parameter_data"", 10);
    }

    void publishData()
    {
        std_msgs::Float32 msg;
        msg.data = param1_ + param2_;

        // Publish data
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    float param1_;
    float param2_;
};

int main(int argc, char** argv)
{
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_component_node"");
    
    // Create an instance of ParameterComponent
    ParameterComponent pc;

    // Set the loop rate
    ros::Rate rate(1); // 1Hz

    while (ros::ok())
    {
        // Publish parameter data
        pc.publishData();

        // Spin and sleep
        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}",0
247,parameter publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Float64.h>

class ParameterPublisherNode {
public:
    ParameterPublisherNode() : nh_(""~"") {
        // Initialize node handle
        nh_.param(""publish_rate"", publish_rate_, 1.0);

        // Create publisher
        pub_ = nh_.advertise<std_msgs::Float64>(""parameter_value"", 10);

        // Setup timer for publishing
        timer_ = nh_.createTimer(ros::Duration(1.0 / publish_rate_), &ParameterPublisherNode::publishParamValue, this);
    }

    void publishParamValue(const ros::TimerEvent&) {
        std_msgs::Float64 msg;
        // Get parameter value
        nh_.getParam(""some_parameter"", msg.data);
        
        // Publish the parameter value
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    ros::Timer timer_;
    double publish_rate_;
};

int main(int argc, char** argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");

    // Create ParameterPublisherNode object
    ParameterPublisherNode node;

    // Spin
    ros::spin();

    return 0;
}",9.11218070482386
249,component code publisher with cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""number_publisher"");
    ros::NodeHandle nh;

    // Create a publisher that publishes messages of type std_msgs::Int32 on the 'random_numbers' topic
    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""random_numbers"", 10);

    // Set the loop rate to 1Hz
    ros::Rate loop_rate(1);

    while (ros::ok())
    {
        // Create a message object of type std_msgs::Int32
        std_msgs::Int32 msg;

        // Generate a random number between 0 and 100
        msg.data = rand() % 100;

        // Publish the random number
        pub.publish(msg);

        // Log the published number to the console
        ROS_INFO(""Published: %d"", msg.data);

        // Spin once to let the node callback functions run
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",9.126793367439639
251,factor code publisher publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

class FactorPublisherNode
{
public:
    FactorPublisherNode()
    {
        pub_ = nh_.advertise<std_msgs::Int32>(""factor_topic"", 10);
    }

    void publishFactors(int number)
    {
        std_msgs::Int32 msg;
        for (int i = 1; i <= number; ++i)
        {
            if (number % i == 0)
            {
                msg.data = i;
                pub_.publish(msg);
            }
        }
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, ""factor_publisher_node"");

    FactorPublisherNode factorPublisher;

    int number;
    ros::NodeHandle nh_private(""~"");
    nh_private.param(""number_to_factor"", number, 10);

    ros::Rate rate(1); // 1Hz
    while (ros::ok())
    {
        factorPublisher.publishFactors(number);
        rate.sleep();
    }

    return 0;
}",8.733533976894943
252,data parameter code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""data_parameter_publisher"");
    ros::NodeHandle nh;

    // Create a publisher that publishes data parameter to the 'data_topic' topic
    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""data_topic"", 10);

    // Set the loop rate (in Hz)
    ros::Rate loop_rate(1); // Publish at 1 Hz

    int data_parameter = 0;

    while (ros::ok()) {
        std_msgs::Int32 msg;
        data_parameter++;

        // Set the data parameter value in the message
        msg.data = data_parameter;

        // Publish the message
        pub.publish(msg);

        // Log the published data parameter
        ROS_INFO(""Published data parameter: %d"", msg.data);

        // Spin once to allow the messages to be processed
        ros::spinOnce();

        // Sleep for the defined loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.877347090986534
256,variable code cpp,"#include <ros/ros.h>

class MyNode {
public:
    MyNode() {
        // Initialize ROS node handle
        nh = ros::NodeHandle(""~"");

        // Subscribe to a topic
        sub = nh.subscribe(""input_topic"", 10, &MyNode::topicCallback, this);

        // Advertise a topic
        pub = nh.advertise<std_msgs::String>(""output_topic"", 10);
    }

    void topicCallback(const std_msgs::String::ConstPtr &msg) {
        // Process the received message
        std_msgs::String output_msg;
        output_msg.data = ""Processed: "" + msg->data;

        // Publish the processed message
        pub.publish(output_msg);
    }

private:
    ros::NodeHandle nh;
    ros::Subscriber sub;
    ros::Publisher pub;
};

int main(int argc, char **argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""my_node"");

    // Create an instance of MyNode
    MyNode my_node;

    // Spin the node
    ros::spin();

    return 0;
}",0
260,rate parameter code ROS pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""talker"");
    ros::NodeHandle nh;

    // Retrieve the rate parameter from the command line (default: 10Hz)
    double rate;
    nh.param(""rate"", rate, 10.0);
    ros::Rate loop_rate(rate);

    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    int count = 0;
    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = ""Hello ROS! "" + std::to_string(count);

        ROS_INFO(""%s"", msg.data.c_str());

        chatter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",9.179313277650591
263,parameter parameter code cpp,"#include <ros/ros.h>

class ParameterNode {
public:
    ParameterNode() {
        // Initialize ROS node handle
        ros::NodeHandle nh;
        
        // Define parameters
        double param1;
        std::string param2;
        
        // Get parameters from the ROS parameter server
        nh.param(""param1"", param1, 1.0);
        nh.param<std::string>(""param2"", param2, ""default_value"");
        
        // Display the parameters
        ROS_INFO(""param1: %.2f"", param1);
        ROS_INFO(""param2: %s"", param2.c_str());
    }
};

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_node"");
    
    // Create an instance of the ParameterNode class
    ParameterNode parameter_node;
    
    // Spin to process callback functions
    ros::spin();
    
    return 0;
}",4.4452759234887465
266,sensor parameter code publisher with cpp,"#include ""ros/ros.h""
#include ""std_msgs/Float32.h""

class SensorParameterPublisher {
private:
    ros::NodeHandle nh;
    ros::Publisher parameter_pub;
    float sensor_parameter;

public:
    SensorParameterPublisher() : sensor_parameter(0.0) {
        parameter_pub = nh.advertise<std_msgs::Float32>(""sensor_parameter"", 10);
    }

    void updateSensorParameter(float new_parameter) {
        sensor_parameter = new_parameter;

        std_msgs::Float32 parameter_msg;
        parameter_msg.data = sensor_parameter;
        
        parameter_pub.publish(parameter_msg);
    }
};

int main(int argc, char **argv) {
    ros::init(argc, argv, ""sensor_parameter_publisher"");
    SensorParameterPublisher sensor_publisher;

    ros::Rate loop_rate(1); // Publish rate of 1 Hz

    while (ros::ok()) {
        // Update sensor parameter (for demonstration purposes)
        float new_parameter = 1.23;
        sensor_publisher.updateSensorParameter(new_parameter);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.867568322863981
288,parameter code cpp,"#include <ros/ros.h>

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_node"");
    ros::NodeHandle nh;

    // Retrieve the publishing rate from the parameter server
    double rate;
    if (!nh.getParam(""/rate"", rate)) {
        ROS_ERROR(""Failed to retrieve parameter 'rate'. Using default rate of 1 Hz."");
        rate = 1.0;  // Default publishing rate if parameter is not found
    }

    // Create a ROS publisher
    ros::Publisher pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the publishing rate
    ros::Rate loop_rate(rate);

    while (ros::ok()) {
        // Publish a message
        std_msgs::String msg;
        msg.data = ""Hello, world!"";
        pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",0
297,parameter code publisher control with cpp,"#include <ros/ros.h>

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Define a parameter name and initial value
    std::string param_name = ""/my_parameter"";
    int param_value = 0;

    // Publish the parameter on the ROS parameter server
    nh.setParam(param_name, param_value);

    // Create a ROS timer to update the parameter value every second
    ros::Rate rate(1); // 1Hz
    while (ros::ok()) {
        param_value++;
        nh.setParam(param_name, param_value);

        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}",3.992539568248055
300,parameter code ROS pub cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Define a parameter with a default value
    std::string message;
    nh.param<std::string>(""/chatter_message"", message, ""Hello, ROS!"");

    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 1000);
    ros::Rate loop_rate(10);

    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = message;

        chatter_pub.publish(msg);
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.192735048918474
307,parameter parameter code interface publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Float32.h>

class ParameterCodeInterface
{
public:
    ParameterCodeInterface()
    {
        // Initialize ROS node handle
        nh = ros::NodeHandle();

        // Define publisher for sending float values
        pub = nh.advertise<std_msgs::Float32>(""float_topic"", 10);

        // Get a private handle to set parameters specific to this node
        private_nh = ros::NodeHandle(""~"");

        // Load parameters
        private_nh.param<float>(""example_param"", example_param, 1.0);
    }

    void publishFloatValue(float value)
    {
        std_msgs::Float32 msg;
        msg.data = value;
        pub.publish(msg);
    }

private:
    ros::NodeHandle nh;
    ros::Publisher pub;
    ros::NodeHandle private_nh;

    float example_param;
};

int main(int argc, char **argv)
{
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_code_interface_node"");

    // Create an instance of ParameterCodeInterface
    ParameterCodeInterface pci;

    // Main loop
    ros::Rate loop_rate(10); // 10Hz
    while (ros::ok())
    {
        pci.publishFloatValue(pci.example_param);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",0
313,parameter code publisher code message with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

# Define the ROS Node
class ParameterPublisherNode:
    def __init__(self):
        rospy.init_node('parameter_publisher_node', anonymous=True)

        # Get the parameter value from the ROS Parameter Server
        self.message_param = rospy.get_param('~message_param', 'Hello, ROS!')

        # Initialize the Publisher
        self.pub = rospy.Publisher('chatter', String, queue_size=10)

    # Publish message in a loop
    def publish_message(self):
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            message = String()
            message.data = self.message_param
            self.pub.publish(message)
            rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher = ParameterPublisherNode()
        parameter_publisher.publish_message()
    except rospy.ROSInterruptException:
        pass",0
317,parameter code pub cpp execution with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv)
{
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Create a parameter for the frequency of publishing messages
    double publish_frequency;
    nh.param(""publish_frequency"", publish_frequency, 1.0);

    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    ros::Rate loop_rate(publish_frequency);

    int count = 0;
    while (ros::ok())
    {
        std_msgs::String msg;
        msg.data = ""Hello, world! Count: "" + std::to_string(count);

        ROS_INFO(""%s"", msg.data.c_str());

        chatter_pub.publish(msg);

        ros::spinOnce();

        loop_rate.sleep();
        count++;
    }

    return 0;
}",8.911505982279902
326,parameter code publisher with system,"#!/usr/bin/env python

import rospy

def parameter_publisher():
    # Initialize the ROS Node with a unique name
    rospy.init_node('parameter_publisher', anonymous=True)
    
    # Set the parameter 'system' with the value 'ROS'
    rospy.set_param('system', 'ROS')

    # Create a Publisher to publish the parameter
    param_pub = rospy.Publisher('system_param', String, queue_size=10)

    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        # Publish the parameter value on the topic
        param_pub.publish(rospy.get_param('system'))
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher()
    except rospy.ROSInterruptException:
        pass",0
331,parameter code publisher publisher,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_publisher():
    rospy.init_node('parameter_publisher', anonymous=True)
    rate = rospy.Rate(1)  # 1Hz

    # Read a parameter from the ROS parameter server
    param_value = rospy.get_param('~param_name', 'default_value')

    pub = rospy.Publisher('parameter_topic', String, queue_size=10)

    while not rospy.is_shutdown():
        pub.publish(param_value)
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher()
    except rospy.ROSInterruptException:
        pass",0
333,parameter parameter sensor code publisher publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class SensorPublisherNode:
    def __init__(self):
        rospy.init_node('sensor_publisher_node', anonymous=True)
        self.sensor_data = ""Hello, world!""
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        self.rate = rospy.Rate(1)  # 1 Hz

    def publish_data(self):
        while not rospy.is_shutdown():
            self.pub.publish(self.sensor_data)
            self.rate.sleep()

if __name__ == '__main__':
    try:
        sensor_publisher = SensorPublisherNode()
        sensor_publisher.publish_data()
    except rospy.ROSInterruptException:
        pass",0
348,parameter code publisher publisher process cpp,"#include <ros/ros.h>
#include <std_msgs/String.h>

class ParameterCodePublisher
{
public:
    ParameterCodePublisher()
    {
        // Initialize ROS node handle
        nh = ros::NodeHandle();

        // Define publisher for parameter codes
        pub = nh.advertise<std_msgs::String>(""parameter_codes"", 10);
    }

    void publishParameterCode(const std::string& code)
    {
        std_msgs::String msg;
        msg.data = code;
        pub.publish(msg);
    }

private:
    ros::NodeHandle nh;
    ros::Publisher pub;
};

int main(int argc, char** argv)
{
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_code_publisher"");

    // Create an instance of the ParameterCodePublisher class
    ParameterCodePublisher parameterCodePublisher;

    // Rate at which parameter codes are published (in Hz)
    ros::Rate rate(1); // 1 Hz

    while (ros::ok())
    {
        // Publish parameter code
        parameterCodePublisher.publishParameterCode(""PARAM123"");

        // Sleep for the remaining time to maintain the specified rate
        rate.sleep();
    }

    return 0;
}",8.71055373292603
353,parameter variable code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_variable_publisher"");
    ros::NodeHandle nh;

    // Retrieve the parameter value from the parameter server
    int param_value;
    if (!nh.getParam(""/my_parameter"", param_value)) {
        ROS_ERROR(""Failed to retrieve parameter value. Using default value."");
        param_value = 10; // Use a default value if parameter retrieval fails
    }

    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""parameter_topic"", 10);
    ros::Rate loop_rate(1); // Publish at 1Hz

    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = param_value;
        pub.publish(msg);
        ROS_INFO(""Published: %d"", msg.data);
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.746742425471796
357,parameter code code publisher system cpp,"#include <ros/ros.h>
#include <std_msgs/String.h>

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle nh;

    // Define parameters
    std::string param_name;
    if (!nh.getParam(""/param_name"", param_name)) {
        ROS_ERROR(""Failed to get parameter '/param_name'"");
        return 1;
    }

    // Create a parameter publisher
    ros::Publisher param_pub = nh.advertise<std_msgs::String>(""parameter_topic"", 10);

    ros::Rate loop_rate(10);

    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = param_name;

        // Publish parameter value
        param_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",3.56542853377103
368,parameter code publisher with message cpp,"// ROS Headers
#include <ros/ros.h>
#include <std_msgs/Int32.h>

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");

    // Create a NodeHandle for interacting with the ROS system
    ros::NodeHandle nh;

    // Create a publisher that will publish an integer parameter
    ros::Publisher param_pub = nh.advertise<std_msgs::Int32>(""parameter_value"", 10);

    // Set the rate at which you want to loop (in Hz)
    ros::Rate loop_rate(1);  // 1Hz
  
    // Main loop to publish the parameter value
    while (ros::ok()) {
        // Create an Int32 message to publish
        std_msgs::Int32 param_msg;
        // Set the parameter value
        param_msg.data = 42;  // Example parameter value
        
        // Publish the message
        param_pub.publish(param_msg);

        // Spin once to process callbacks
        ros::spinOnce();

        // Sleep for the remaining time to achieve the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.720493338332416
393,parameter code parameter planning code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterPlanningNode:
    def __init__(self):
        rospy.init_node('parameter_planning_node', anonymous=True)
        self.rate = rospy.Rate(1)  # 1 Hz
        self.param_value = rospy.get_param('~param_value', 0)  # Default param_value is 0

        rospy.Subscriber('chatter', String, self.chatter_callback)

    def chatter_callback(self, msg):
        rospy.loginfo('Received: %s', msg.data)
        # Your parameter planning algorithm here
        if len(msg.data) > self.param_value:
            rospy.set_param('~param_value', len(msg.data))
            rospy.loginfo('Updated param_value to: %d', len(msg.data))

    def run(self):
        while not rospy.is_shutdown():
            self.rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterPlanningNode()
        node.run()
    except rospy.ROSInterruptException:
        pass",0
396,factor code publisher with cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main(int argc, char **argv) {
    ros::init(argc, argv, ""factor_publisher"");
    ros::NodeHandle nh;

    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""factorial_numbers"", 10);
    ros::Rate rate(1); // Publish at 1 Hz

    int number = 1;
    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = number;

        ROS_INFO(""Publishing number: %d"", msg.data);
        pub.publish(msg);

        int fact = factorial(number);
        ROS_INFO(""Factorial of %d is %d"", number, fact);

        number++;
        rate.sleep();
    }

    return 0;
}",8.597612131511282
408,parameter launch code publisher publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");

    // Create a NodeHandle object
    ros::NodeHandle nh;

    // Create a publisher for the parameter value
    ros::Publisher param_pub = nh.advertise<std_msgs::Int32>(""parameter_topic"", 10);

    // Set the parameter value
    int parameter_value = 42;

    // Main loop to publish the parameter value
    ros::Rate loop_rate(1); // 1 Hz
    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = parameter_value;

        // Publish the parameter value
        param_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.913145954083456
417,variable code publisher code publisher publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_publisher():
    # Initialize ROS node
    rospy.init_node('chatter_publisher', anonymous=True)

    # Create a publisher with topic 'chatter' and message type String
    publisher = rospy.Publisher('chatter', String, queue_size=10)

    # Set the loop rate (Hz)
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        # Create a String message
        message = String()
        message.data = 'Hello, world!'

        # Publish the message
        publisher.publish(message)

        # Log the message being published
        rospy.loginfo('Publishing: %s', message.data)

        # Sleep to maintain the loop rate
        rate.sleep()

if __name__ == '__main__':
    try:
        chatter_publisher()
    except rospy.ROSInterruptException:
        pass",0
426,parameter code publisher code publisher cpp,"#include <ros/ros.h>
#include <std_msgs/Int32.h>

int main(int argc, char** argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Get the parameter value from the ROS Parameter Server
    int parameter_value;
    if (!nh.getParam(""my_parameter"", parameter_value)) {
        ROS_ERROR(""Failed to get parameter value!"");
        return 1;
    }

    // Create a publisher for publishing the parameter value
    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""parameter_topic"", 10);

    ros::Rate rate(1); // 1 Hz

    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = parameter_value;
        pub.publish(msg);

        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}",8.657070607045638
428,parameter code publisher message with cpp,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher_node"");
    ros::NodeHandle nh;

    // Get the parameter value from the parameter server
    std::string param_value;
    if (!nh.getParam(""your_parameter_name"", param_value)) {
        ROS_ERROR(""Failed to get parameter value"");
        return 1;
    }

    // Create a publisher for the parameter value
    ros::Publisher param_pub = nh.advertise<std_msgs::String>(""parameter_topic"", 10);

    ros::Rate loop_rate(10); // Publish at 10Hz

    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = param_value;

        param_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",3.45790364739921
430,parameter parameter cpp,"#include <ros/ros.h>

class ParameterNode {
public:
    ParameterNode() {
        // Initialize node handle
        ros::NodeHandle nh;

        // Setup parameters
        nh.param<std::string>(""/my_parameter"", my_param_, ""default_value"");
    }

    void run() {
        // Main loop
        while (ros::ok()) {
            // Use the parameter
            ROS_INFO(""Value of my_parameter: %s"", my_param_.c_str());

            // Sleep for a while
            ros::Duration(1.0).sleep();
        }
    }

private:
    std::string my_param_;
};

int main(int argc, char **argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_node"");

    ParameterNode node;

    // Run the node
    node.run();

    return 0;
}",3.567383452328719
433,parameter code code cpp,"#include <ros/ros.h>

// Include necessary message files
#include <std_msgs/String.h>

// Callback function to process incoming messages
void messageCallback(const std_msgs::String::ConstPtr& msg)
{
    // Process the received message here
    ROS_INFO(""Received message: %s"", msg->data.c_str());
}

int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_node"");

    // Create a NodeHandle for interacting with the ROS system
    ros::NodeHandle nh;

    // Subscribe to the ""input_topic"" topic with a queue size of 10 and specify the callback function
    ros::Subscriber sub = nh.subscribe(""input_topic"", 10, messageCallback);

    // Main loop to keep the node running
    while (ros::ok())
    {
        // Process any callbacks and publish any outgoing messages
        ros::spinOnce();

        // Add any custom node logic here
    }

    return 0;
}",3.6839443557747207
445,robot parameter code sensor code publisher cpp,"#include <ros/ros.h>
#include <sensor_msgs/LaserScan.h>

class RobotParams
{
public:
    RobotParams() : nh_(""~"")
    {
        nh_.param<std::string>(""robot_name"", robot_name_, ""turtlebot"");
        nh_.param<int>(""wheel_count"", wheel_count_, 2);
        nh_.param<double>(""max_speed"", max_speed_, 1.0);
    }

    std::string getRobotName() const { return robot_name_; }
    int getWheelCount() const { return wheel_count_; }
    double getMaxSpeed() const { return max_speed_; }

private:
    ros::NodeHandle nh_;
    std::string robot_name_;
    int wheel_count_;
    double max_speed_;
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, ""sensor_publisher"");
    ros::NodeHandle nh;

    RobotParams params;

    ros::Publisher sensor_pub = nh.advertise<sensor_msgs::LaserScan>(""sensor_data"", 10);

    ros::Rate loop_rate(1); // Publish at 1Hz

    while (ros::ok())
    {
        sensor_msgs::LaserScan msg;
        // Fill in the LaserScan message data here

        sensor_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",8.609435730306647
451,launch parameter code publisher publisher cpp,"#include <ros/ros.h>

int main(int argc, char** argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Publish a parameter to ROS Parameter Server
    nh.setParam(""/my_parameter"", 42);

    // Loop at 1Hz
    ros::Rate rate(1);
    while (ros::ok()) {
        // Publish parameter value
        ROS_INFO(""Publishing parameter: /my_parameter = %d"", 42);

        // Sleep to maintain 1Hz loop rate
        rate.sleep();
    }

    return 0;
}",4.021056805887481
458,parameter code publisher with planning cpp,"#include <ros/ros.h>
#include <dynamic_reconfigure/server.h>
#include <your_package/YourConfig.h>

void callback(your_package::YourConfig &config, uint32_t level) {
  // Add any desired functionality here based on the received parameters
  ROS_INFO(""Reconfigured parameters: %d, %f"", 
           config.int_param, config.double_param);
}

int main(int argc, char** argv) {
  ros::init(argc, argv, ""parameter_publisher_node"");
  ros::NodeHandle nh;

  dynamic_reconfigure::Server<your_package::YourConfig> server;
  dynamic_reconfigure::Server<your_package::YourConfig>::CallbackType f;
  f = boost::bind(&callback, _1, _2);
  server.setCallback(f);

  ROS_INFO(""Parameter Publisher Node Started"");

  ros::Rate loop_rate(1);  // Adjust the publishing rate as needed

  while (ros::ok()) {
    your_package::YourConfig msg;
    msg.int_param = 1;
    msg.double_param = 3.14;

    server.updateConfig(msg);  // Publish the parameters

    ros::spinOnce();
    loop_rate.sleep();
  }

  return 0;
}",0
462,parameter code publisher with publisher cpp,"#include ""ros/ros.h""

int main(int argc, char** argv)
{
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Set the parameter value to be published
    nh.setParam(""/my_parameter"", 42);

    // Create a publisher for the parameter value
    ros::Publisher param_pub = nh.advertise<int>(""/my_parameter"", 1);

    // Set the publishing frequency (in Hz)
    double publish_frequency = 1.0; // 1 Hz
    ros::Rate loop_rate(publish_frequency);

    while (ros::ok())
    {
        // Get the parameter value
        int param_value;
        nh.getParam(""/my_parameter"", param_value);

        // Publish the parameter value
        param_pub.publish(param_value);

        // Sleep to maintain the publishing frequency
        loop_rate.sleep();
    }

    return 0;
}",0
463,parameter execution code publisher planning with cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_execution_publisher"");
    ros::NodeHandle nh;

    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""/parameter_executions"", 10);

    ros::Rate loop_rate(10); // 10Hz publishing rate

    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = 42; // Example parameter execution data

        pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",9.216750077467157
464,parameter execution publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterExecutionPublisher:
    def __init__(self):
        rospy.init_node('parameter_execution_publisher', anonymous=True)
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        self.param_value = rospy.get_param('~param_value', 'default_value')  # Get parameter value from ROS parameter server

    def publish_message(self):
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            message = ""Executing with param value: {}"".format(self.param_value)
            rospy.loginfo(message)
            self.pub.publish(message)
            rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterExecutionPublisher()
        node.publish_message()
    except rospy.ROSInterruptException:
        pass",0
465,parameter execution code publisher topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_publisher():
    # Initialize the ROS node
    rospy.init_node('parameter_publisher', anonymous=True)

    # Get parameters from the ROS Parameter Server
    custom_param = rospy.get_param('~custom_param', 'Default Value')

    # Create a publisher for the topic '/chatter' with String messages
    pub = rospy.Publisher('/chatter', String, queue_size=10)

    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        # Publish the custom parameter as a message
        pub.publish(custom_param)

        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher()
    except rospy.ROSInterruptException:
        pass",0
469,parameter execution code publisher planning sensor chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterExecutionNode:
    def __init__(self):
        rospy.init_node('parameter_execution_node', anonymous=True)

        # Load a parameter from the parameter server
        self.some_parameter = rospy.get_param('~some_parameter', 'default_value')

        self.sensor_data_sub = rospy.Subscriber('sensor_data', String, self.sensor_data_callback)
        self.sensor_chatter_pub = rospy.Publisher('sensor_chatter', String, queue_size=10)

    def sensor_data_callback(self, data):
        rospy.loginfo('Received sensor data: %s', data.data)

        # Perform some planning based on sensor data
        planned_action = self.plan_action(data.data)

        # Publish to the sensor_chatter topic
        self.sensor_chatter_pub.publish(planned_action)

    def plan_action(self, sensor_data):
        # This is a placeholder for planning some action based on sensor data
        planned_action = 'Planned action based on sensor data: {}'.format(sensor_data)
        return planned_action

if __name__ == '__main__':
    try:
        node = ParameterExecutionNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass",0
470,parameter execution code parameter publisher topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_publisher():
    # Initialize the ROS Node
    rospy.init_node('parameter_publisher', anonymous=True)

    # Get the parameter value from the ROS Parameter Server
    if not rospy.has_param('~message_param'):
        rospy.logerr(""Parameter 'message_param' not found"")
        return

    message_param = rospy.get_param('~message_param')

    # Create a Publisher to publish messages to the 'chatter' topic
    pub = rospy.Publisher('chatter', String, queue_size=10)
    
    # Set the loop rate (in Hz)
    rate = rospy.Rate(1)  # 1Hz

    while not rospy.is_shutdown():
        # Publish the message parameter value to the 'chatter' topic
        pub.publish(message_param)
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher()
    except rospy.ROSInterruptException:
        pass",0
471,parameter execution code publisher planning chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterExecutionNode:
    def __init__(self):
        rospy.init_node('parameter_execution_node', anonymous=True)
        
        # Initialize parameters
        self.execution_rate = rospy.get_param('~execution_rate', 1.0)  # default rate is 1.0 Hz
        
        # Publisher to publish planning chatter
        self.chatter_pub = rospy.Publisher('planning_chatter', String, queue_size=10)
        
    def run(self):
        rate = rospy.Rate(self.execution_rate)
        
        while not rospy.is_shutdown():
            planning_message = ""Executing planning...""
            rospy.loginfo(planning_message)
            self.chatter_pub.publish(planning_message)
            rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterExecutionNode()
        node.run()
    except rospy.ROSInterruptException:
        pass",0
473,parameter execution code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterWithChatterNode:
    def __init__(self):
        rospy.init_node('parameter_with_chatter_node', anonymous=True)

        self.param_value = rospy.get_param('~param_value', 'default_param_value')
        self.chatter_topic = rospy.get_param('~chatter_topic', 'chatter')

        rospy.Subscriber(self.chatter_topic, String, self.chatter_callback)

    def chatter_callback(self, msg):
        rospy.loginfo(""Received message: %s"", msg.data)
        rospy.loginfo(""Parameter value: %s"", self.param_value)

    def run(self):
        rate = rospy.Rate(10)  # 10Hz
        while not rospy.is_shutdown():
            rospy.loginfo(""Executing... Parameter value: %s"", self.param_value)
            rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterWithChatterNode()
        node.run()
    except rospy.ROSInterruptException:
        pass",0
478,parameter execution code with subject chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_callback(msg):
    rospy.loginfo(""Received message: %s"", msg.data)

def chatter_listener():
    rospy.init_node('chatter_listener', anonymous=True)
    rospy.Subscriber('chatter', String, chatter_callback)
    rospy.spin()

if __name__ == '__main__':
    try:
        chatter_listener()
    except rospy.ROSInterruptException:
        pass",0
481,parameter execution code publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Int32.h""

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_publisher"");
    ros::NodeHandle nh;

    // Get the value of parameter 'frequency' from the parameter server
    double frequency;
    if (!nh.getParam(""/parameter_publisher/frequency"", frequency)) {
        ROS_ERROR(""Failed to get parameter 'frequency'. Using default value of 1.0"");
        frequency = 1.0;
    }

    // Create a publisher for publishing integer messages to the topic 'parameter_data'
    ros::Publisher pub = nh.advertise<std_msgs::Int32>(""parameter_data"", 10);
    
    ros::Rate loop_rate(frequency);

    int count = 0;
    while (ros::ok()) {
        std_msgs::Int32 msg;
        msg.data = count;

        pub.publish(msg);
        ROS_INFO(""Published: %d"", msg.data);

        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",8.733879123697022
483,parameter parameter code publisher publisher cpp,"#include ""ros/ros.h""
#include ""std_msgs/Float64.h""

class ParameterPublisherNode {
public:
    ParameterPublisherNode() : nh_(""~"") {
        // Initialize node handle
        nh_.param(""publish_rate"", publish_rate_, 1.0);

        // Create publisher
        pub_ = nh_.advertise<std_msgs::Float64>(""parameter_value"", 10);

        // Timer for publishing
        timer_ = nh_.createTimer(ros::Duration(1.0/publish_rate_), &ParameterPublisherNode::publishParameterValue, this);
    }

    void publishParameterValue(const ros::TimerEvent& event) {
        std_msgs::Float64 msg;
        nh_.getParam(""parameter_value"", msg.data);
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    ros::Timer timer_;
    double publish_rate_;
};

int main(int argc, char** argv) {
    // Initialize ROS node
    ros::init(argc, argv, ""parameter_publisher_node"");
    ParameterPublisherNode node;

    ros::spin();

    return 0;
}",9.127777377084739
485,parameter execution code interface with topic planning chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterExecutionNode:
    def __init__(self):
        # Initialize ROS node
        rospy.init_node('parameter_execution_node', anonymous=True)

        # Subscribe to the planning chatter topic
        rospy.Subscriber('planning_chatter', String, self.planning_callback)

        # Define a publisher for execution chatter topic
        self.execution_pub = rospy.Publisher('execution_chatter', String, queue_size=10)

        # Spin to keep the node alive
        rospy.spin()

    def planning_callback(self, data):
        # Callback function to process planning data
        rospy.loginfo(""Received planning data: %s"", data.data)
        # Process the planning data and perform some actions

        # Generate execution result
        execution_result = ""Executing the planned path""

        # Publish the execution result to the execution chatter topic
        self.execution_pub.publish(execution_result)
        rospy.loginfo(""Execution result published: %s"", execution_result)


if __name__ == '__main__':
    try:
        param_execution_node = ParameterExecutionNode()
    except rospy.ROSInterruptException:
        pass",0
486,execution code publisher planning chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_publisher():
    # Initialize ROS node with a unique name
    rospy.init_node('chatter_publisher', anonymous=True)

    # Create a publisher on the topic '/chatter' with message type String
    pub = rospy.Publisher('/chatter', String, queue_size=10)

    # Set the loop rate (in Hz)
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        # Create a String message with the desired content
        message = ""Hello, ROS!""
        rospy.loginfo(message)  # Log the message to the console

        # Publish the message on the topic '/chatter'
        pub.publish(message)

        rate.sleep()  # Wait until it's time for the next iteration

if __name__ == '__main__':
    try:
        chatter_publisher()
    except rospy.ROSInterruptException:
        pass",0
487,parameter code publisher with system topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterPublisher:
    def __init__(self):
        rospy.init_node('parameter_publisher', anonymous=True)
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        self.rate = rospy.Rate(1)  # 1 Hz

    def publish_parameter(self):
        while not rospy.is_shutdown():
            # Publish a static message as an example parameter
            parameter_value = ""example_parameter""
            rospy.loginfo(""Publishing parameter: {}"".format(parameter_value))
            self.pub.publish(parameter_value)
            self.rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher = ParameterPublisher()
        parameter_publisher.publish_parameter()
    except rospy.ROSInterruptException:
        pass",0
489,parameter execution code with cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

// Callback function to process messages from the 'chatter' topic
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
  ROS_INFO(""I heard: [%s]"", msg->data.c_str());
}

int main(int argc, char **argv)
{
  // Initialize the ROS node
  ros::init(argc, argv, ""listener"");

  // Create a node handle
  ros::NodeHandle nh;

  // Subscribe to the 'chatter' topic with a queue size of 10 and specify the callback function
  ros::Subscriber sub = nh.subscribe(""chatter"", 10, chatterCallback);

  // Spin to receive messages
  ros::spin();

  return 0;
}",4.485957663214056
490,parameter operation code publisher planning topic chatter,"#! /usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterOperationNode:
    def __init__(self):
        rospy.init_node('parameter_operation_node', anonymous=True)
        self.pub = rospy.Publisher('chatter', String, queue_size=10)

        # Get parameter from the parameter server
        self.param_value = rospy.get_param('~param_name', 'default_value')

    def publish_message(self):
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            self.pub.publish(self.param_value)
            rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterOperationNode()
        node.publish_message()
    except rospy.ROSInterruptException:
        pass",0
493,factor execution publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import UInt64

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

def factor_execution_publisher():
    rospy.init_node('factor_execution_publisher', anonymous=True)
    pub = rospy.Publisher('chatter', UInt64, queue_size=10)
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        factorial_value = factorial(5)  # Calculate factorial of 5 (you can use any other number)
        rospy.loginfo(""Publishing factorial value: %d"" % factorial_value)
        pub.publish(factorial_value)
        rate.sleep()

if __name__ == '__main__':
    try:
        factor_execution_publisher()
    except rospy.ROSInterruptException:
        pass",0
496,actuator parameter execution code publisher planning chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ActuatorParameterNode:
    def __init__(self):
        # Initialize the ROS Node
        rospy.init_node('actuator_parameter_node', anonymous=True)
        
        # Define the actuator parameter
        self.actuator_parameter = None
        
        # Create a publisher for the ""chatter"" topic
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        
        # Subscribe to the ""chatter"" topic to receive messages
        rospy.Subscriber('chatter', String, self.chatter_callback)
        
        # Run the main loop
        self.run()
    
    def chatter_callback(self, data):
        # Callback function to handle incoming messages on the ""chatter"" topic
        rospy.loginfo(rospy.get_caller_id() + ""I heard %s"", data.data)
        # Execute the actuator parameter
        self.execute_actuator_parameter()
    
    def execute_actuator_parameter(self):
        # Function to execute the actuator parameter
        if self.actuator_parameter is not None:
            # Execute the actuator parameter here
            rospy.loginfo(""Executing actuator parameter: %s"", self.actuator_parameter)
    
    def run(self):
        # Main loop of the node
        rate = rospy.Rate(10) # 10Hz
        while not rospy.is_shutdown():
            # Publish a message to the ""chatter"" topic
            self.pub.publish(""Executing Actuator Parameter"")
            rate.sleep()

if __name__ == '__main__':
    try:
        # Create an instance of the ActuatorParameterNode class
        node = ActuatorParameterNode()
    except rospy.ROSInterruptException:
        pass",0
498,parameter message execution publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterMessageExecutionPublisher:
    def __init__(self):
        rospy.init_node('parameter_message_execution_publisher', anonymous=True)
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        self.rate = rospy.Rate(1)  # 1Hz

    def publish_message(self, message):
        msg = String()
        msg.data = message
        rospy.loginfo(""Publishing message: %s"" % message)
        self.pub.publish(msg)
        self.rate.sleep()

if __name__ == '__main__':
    try:
        publisher = ParameterMessageExecutionPublisher()
        message = rospy.get_param('~message', 'Default message')
        while not rospy.is_shutdown():
            publisher.publish_message(message)
    except rospy.ROSInterruptException:
        pass",0
501,parameter execution code with actuator topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import Float32

class ActuatorControllerNode:
    def __init__(self):
        rospy.init_node('actuator_controller_node', anonymous=True)
        
        # Subscribe to actuator topic
        rospy.Subscriber('actuator_topic', Float32, self.actuator_callback)
        
        # Define parameters
        self.threshold = rospy.get_param('~threshold', 0.5)
        self.max_value = rospy.get_param('~max_value', 1.0)
        
    def actuator_callback(self, data):
        if data.data > self.threshold:
            self.perform_action(data.data)
    
    def perform_action(self, value):
        # Perform action based on the received value
        # For example, control an actuator with the value
        # Ensure to implement this method based on your application needs
        print(""Performing action with value: {}"".format(value))
        
def main():
    actuator_controller = ActuatorControllerNode()
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass

if __name__ == '__main__':
    main()",0
504,factor code publisher topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import Int32

def factor(num):
    factors = []
    for i in range(1, num + 1):
        if num % i == 0:
            factors.append(i)
    return factors

def chatter():
    pub = rospy.Publisher('factorized_number', Int32, queue_size=10)
    rospy.init_node('factorizer_node', anonymous=True)
    rate = rospy.Rate(1)  # 1Hz

    while not rospy.is_shutdown():
        num = get_number_to_factor()  # Function to get the number to factor from the user
        factors = factor(num)

        pub.publish(Int32(factors))
        rate.sleep()

if __name__ == '__main__':
    try:
        chatter()
    except rospy.ROSInterruptException:
        pass",0
505,parameter execution code publisher strategy chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_publisher():
    # Initialize the ROS Node with the name 'chatter_publisher_node'
    rospy.init_node('chatter_publisher_node', anonymous=True)

    # Create a publisher for the '/chatter' topic with String messages
    pub = rospy.Publisher('/chatter', String, queue_size=10)

    # Set the loop rate to 1Hz
    rate = rospy.Rate(1)

    while not rospy.is_shutdown():
        # Create a String message with the desired content
        message = ""Hello, this is a message from the chatter_publisher_node""
        
        # Publish the message to the '/chatter' topic
        pub.publish(message)
        
        # Log the published message for debugging
        rospy.loginfo(message)
        
        # Sleep to maintain the loop rate
        rate.sleep()

if __name__ == '__main__':
    try:
        chatter_publisher()
    except rospy.ROSInterruptException:
        pass",0
512,parameter execution code publisher action chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String
from actionlib import SimpleActionClient
from your_package.msg import YourActionAction, YourActionGoal

def main():
    rospy.init_node('parameter_execution_publisher_action_chatter_node', anonymous=True)

    # Parameters
    param_name = rospy.get_param('~your_param_name', 'default_value')

    # Publisher
    pub = rospy.Publisher('chatter', String, queue_size=10)

    # Action Client
    client = SimpleActionClient('your_action_server', YourActionAction)
    client.wait_for_server()

    while not rospy.is_shutdown():
        # Your execution control code here

        # Publish message
        message = ""Hello, world! Parameter value: {}"".format(param_name)
        pub.publish(message)

        # Send a goal to the action server
        goal = YourActionGoal()
        goal.some_field = some_value
        client.send_goal(goal)

        # Perform any additional processing

        rospy.sleep(1.0)  # Example wait before publishing again

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass",0
516,parameter implementation code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterListenerNode:
    def __init__(self):
        # Initialize the node
        rospy.init_node('chatter_listener')

        # Get the threshold value from the parameter server, default to 10 if not set
        self.threshold = rospy.get_param('~threshold', 10)

        # Subscribe to the ""/chatter"" topic
        rospy.Subscriber(""/chatter"", String, self.chatter_callback)

    def chatter_callback(self, msg):
        message = msg.data
        if len(message) > self.threshold:
            rospy.loginfo(""Received message: %s"", message)

if __name__ == '__main__':
    try:
        node = ChatterListenerNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass",0
527,parameter execution code publisher planning topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class PlanningPublisher:
    def __init__(self):
        # Initialize the ROS node
        rospy.init_node('planning_publisher')

        # Get parameters from the parameter server
        self.planning_mode = rospy.get_param('~planning_mode', 'fast')

        # Create a publisher for the /chatter topic
        self.pub = rospy.Publisher('/chatter', String, queue_size=10)

    def run(self):
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            # Generate planning information based on the planning_mode parameter
            if self.planning_mode == 'fast':
                planning_info = ""Fast planning in progress...""
            elif self.planning_mode == 'accurate':
                planning_info = ""Accurate planning in progress...""
            else:
                planning_info = ""Unknown planning mode specified...""

            # Publish the planning information to the /chatter topic
            self.pub.publish(planning_info)
            rate.sleep()

if __name__ == '__main__':
    try:
        planning_publisher = PlanningPublisher()
        planning_publisher.run()
    except rospy.ROSInterruptException:
        pass",0
541,parameter execution code with planning cpp,"#include <ros/ros.h>
#include <geometry_msgs/Point.h>
#include <trajectory_msgs/JointTrajectory.h>

// Global variables to store parameters
double workspace_min_x, workspace_max_x, workspace_min_y, workspace_max_y, workspace_min_z, workspace_max_z;
geometry_msgs::Point target_position;

// Function to read parameters from the parameter server
void readParameters(ros::NodeHandle nh) {
    nh.param(""workspace/min_x"", workspace_min_x, -1.0);
    nh.param(""workspace/max_x"", workspace_max_x, 1.0);
    nh.param(""workspace/min_y"", workspace_min_y, -1.0);
    nh.param(""workspace/max_y"", workspace_max_y, 1.0);
    nh.param(""workspace/min_z"", workspace_min_z, -1.0);
    nh.param(""workspace/max_z"", workspace_max_z, 1.0);
    
    nh.param(""target_position/x"", target_position.x, 0.0);
    nh.param(""target_position/y"", target_position.y, 0.0);
    nh.param(""target_position/z"", target_position.z, 0.0);
}

// Function to plan trajectory
trajectory_msgs::JointTrajectory planTrajectory(geometry_msgs::Point target) {
    // Add your trajectory planning code here
    trajectory_msgs::JointTrajectory planned_trajectory;

    // Dummy trajectory planning
    planned_trajectory.points.resize(1);
    planned_trajectory.points[0].positions = {0.1, 0.2, 0.3};
    
    return planned_trajectory;
}

int main(int argc, char** argv) {
    ros::init(argc, argv, ""execution_planning_node"");
    ros::NodeHandle nh;

    readParameters(nh);
    
    trajectory_msgs::JointTrajectory planned_trajectory = planTrajectory(target_position);
    
    // Publish the planned trajectory for execution
    ros::Publisher trajectory_pub = nh.advertise<trajectory_msgs::JointTrajectory>(""planned_trajectory"", 10);
    
    ros::Rate rate(10); // 10 Hz
    while (ros::ok()) {
        trajectory_pub.publish(planned_trajectory);
        ros::spinOnce();
        rate.sleep();
    }
    
    return 0;
}",8.659954950587887
542,parameter execution cpp,"#include ""ros/ros.h""

class ParameterExecutionNode {
public:
    ParameterExecutionNode() {
        ros::NodeHandle nh(""~"");
        
        // Load the target value parameter from the parameter server
        nh.param(""target_value"", target_value_, 10.0);

        // Subscribe to a topic where input values will be received
        input_sub_ = nh.subscribe(""input_values"", 10, &ParameterExecutionNode::inputCallback, this);
    }

    void inputCallback(const std_msgs::Float32::ConstPtr& msg) {
        float input_value = msg->data;

        if (input_value >= target_value_) {
            ROS_INFO_STREAM(""Input value ("" << input_value << "") is greater than or equal to the target value ("" << target_value_ << "")"");
        } else {
            ROS_INFO_STREAM(""Input value ("" << input_value << "") is less than the target value ("" << target_value_ << "")"");
        }
    }

private:
    ros::Subscriber input_sub_;
    float target_value_;
};

int main(int argc, char **argv) {
    ros::init(argc, argv, ""parameter_execution_node"");

    ParameterExecutionNode node;

    ros::spin();

    return 0;
}",0
549,parameter system execution code publisher topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_system_code_publisher():
    # Initialize the ROS Node with the name 'parameter_system_code_publisher'
    rospy.init_node('parameter_system_code_publisher', anonymous=True)

    # Define the topic name to publish the code
    topic_name = 'chatter'

    # Create a Publisher object which can publish String messages to the 'chatter' topic
    pub = rospy.Publisher(topic_name, String, queue_size=10)

    # Set the rate at which to publish the messages (e.g., 1 Hz)
    rate = rospy.Rate(1)

    # Main loop to publish the parameter system execution code
    while not rospy.is_shutdown():
        # Define the parameter system code to be published
        code = ""Your parameter system execution code goes here""

        # Publish the code on the 'chatter' topic
        rospy.loginfo(""Publishing code: %s"" % code)
        pub.publish(String(code))

        # Delay to maintain the specified publishing rate
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_system_code_publisher()
    except rospy.ROSInterruptException:
        pass",0
550,navigation parameter code system publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class NavigationParameterPublisher:
    def __init__(self):
        rospy.init_node('navigation_parameter_publisher', anonymous=True)
        self.param_pub = rospy.Publisher('chatter', String, queue_size=10)
        self.rate = rospy.Rate(1)  # 1 Hz

    def publish_parameters(self):
        while not rospy.is_shutdown():
            # Publish navigation parameters
            nav_params = ""{'velocity': 2.0, 'angular_velocity': 1.0}""
            rospy.loginfo(""Publishing navigation parameters: %s"" % nav_params)
            self.param_pub.publish(nav_params)
            self.rate.sleep()

if __name__ == '__main__':
    try:
        nav_param_publisher = NavigationParameterPublisher()
        nav_param_publisher.publish_parameters()
    except rospy.ROSInterruptException:
        pass",0
552,factor code publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def factor(num):
    """"""Calculate the factors of a given number.""""""
    factors = []
    for i in range(1, num + 1):
        if num % i == 0:
            factors.append(i)
    return factors

def chatter_publisher():
    """"""Publish factors of numbers on the 'chatter' topic.""""""
    rospy.init_node('factor_publisher', anonymous=True)
    pub = rospy.Publisher('chatter', String, queue_size=10)
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        num = int(raw_input(""Enter a number: ""))  # User input for a number
        factors = factor(num)
        message = ""Factors of {}: {}"".format(num, factors)
        rospy.loginfo(message)
        pub.publish(message)
        rate.sleep()

if __name__ == '__main__':
    try:
        chatter_publisher()
    except rospy.ROSInterruptException:
        pass",0
553,parameter publisher with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_publisher():
    # Initialize the ROS Node
    rospy.init_node('parameter_publisher', anonymous=True)

    # Get the parameter value to publish
    parameter_value = rospy.get_param(""~parameter_value"", ""default_value"")

    # Create a publisher with topic 'chatter' and message type 'String'
    pub = rospy.Publisher('chatter', String, queue_size=10)

    # Set the publishing rate
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        # Publish the parameter value on the 'chatter' topic
        pub.publish(parameter_value)
        
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_publisher()
    except rospy.ROSInterruptException:
        pass",0
555,parameter execution publisher with parameter chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def parameter_chatter():
    # Initialize the ROS node with a unique name
    rospy.init_node('parameter_chatter', anonymous=True)

    # Get the parameter 'frequency' from the ROS parameter server
    frequency = rospy.get_param('~frequency', 1.0)

    # Create a publisher that publishes to the 'chatter' topic
    pub = rospy.Publisher('chatter', String, queue_size=10)

    rate = rospy.Rate(frequency)  # Set the publishing rate

    while not rospy.is_shutdown():
        message = ""Hello, parameter chatter! Frequency: {}"".format(frequency)
        rospy.loginfo(message)
        pub.publish(message)
        rate.sleep()

if __name__ == '__main__':
    try:
        parameter_chatter()
    except rospy.ROSInterruptException:
        pass",0
557,parameter code publisher with action chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String
import actionlib
from dynamic_reconfigure.server import Server
from my_package.cfg import MyConfig

class ParameterPublisherNode:
    def __init__(self):
        rospy.init_node('parameter_publisher_node')
        
        self.param_value = 'default_value'
        
        # Create parameter server and set initial parameter value
        rospy.set_param('~my_parameter', self.param_value)
        
        # Dynamic reconfigure server callback
        self.dyn_rec_server = Server(MyConfig, self.dynamic_reconfigure_callback)
        
        # Publisher for parameter value
        self.pub = rospy.Publisher('/chatter', String, queue_size=10)
        
        # Action client for testing
        self.client = actionlib.SimpleActionClient('chatter_action', MyAction)
        
    def dynamic_reconfigure_callback(self, config, level):
        rospy.loginfo(""Reconfigure Request: {my_parameter}"".format(**config))
        self.param_value = config.my_parameter
        rospy.set_param('~my_parameter', self.param_value)
        return config

    def publish_parameter(self):
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            self.pub.publish(self.param_value)
            rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterPublisherNode()
        node.publish_parameter()
    except rospy.ROSInterruptException:
        pass",0
560,parameter code publisher with topic planning chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterPublisher:
    def __init__(self):
        rospy.init_node('parameter_publisher', anonymous=True)
        self.pub = rospy.Publisher('planning_chatter', String, queue_size=10)
        
    def publish_parameter(self, data):
        parameter_value = str(data)  # Convert data to string if needed
        rospy.loginfo(""Publishing parameter: {}"".format(parameter_value))
        self.pub.publish(parameter_value)

if __name__ == '__main__':
    try:
        param_publisher = ParameterPublisher()
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            parameter_data = ""example_parameter""  # Add your parameter data here
            param_publisher.publish_parameter(parameter_data)
            rate.sleep()
    except rospy.ROSInterruptException:
        pass",0
562,parameter execution interface code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterListenerNode:
    def __init__(self):
        # Initialize the ROS Node
        rospy.init_node('chatter_listener_node', anonymous=True)
        
        # Retrieve a parameter from the parameter server
        self.execution_interface = rospy.get_param('~execution_interface', 'default_interface')
        
        # Subscribe to the chatter topic
        rospy.Subscriber('chatter', String, self.chatter_callback)
        
        rospy.loginfo('Chatter Listener Node initialized with execution interface: {}'.format(self.execution_interface))
        
    def chatter_callback(self, msg):
        rospy.loginfo('Received message: {}'.format(msg.data))
        self.execute_action(msg.data)
        
    def execute_action(self, data):
        # Perform some action based on the received message using the execution interface
        rospy.loginfo('Executing action with interface: {} - Data: {}'.format(self.execution_interface, data))
        
    def run(self):
        # Run the ROS Node
        rospy.spin()

if __name__ == '__main__':
    try:
        node = ChatterListenerNode()
        node.run()
    except rospy.ROSInterruptException:
        pass",0
563,parameter execution code publisher cpp with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""parameter_execution_publisher"");

    // Create a node handle
    ros::NodeHandle nh;

    // Create a publisher with a topic named ""chatter"" and a queue size of 10
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);
    
    // Set the frequency for publishing messages in Hz
    double publish_freq;
    nh.getParam(""/publish_frequency"", publish_freq); // Get the parameter value from the parameter server

    ros::Rate loop_rate(publish_freq);

    int count = 0;
    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = ""Hello, ROS! Count: "" + std::to_string(count);

        ROS_INFO(""%s"", msg.data.c_str());

        // Publish the message
        chatter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
        count++;
    }

    return 0;
}",3.6783891021114394
564,parameter execution code publisher topic interface chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_publisher():
    rospy.init_node('chatter_publisher', anonymous=True)
    rate = rospy.Rate(1)  # 1 Hz

    pub = rospy.Publisher('/chatter', String, queue_size=10)

    while not rospy.is_shutdown():
        message = ""Hello, world!""
        rospy.loginfo(message)
        pub.publish(message)
        rate.sleep()

if __name__ == '__main__':
    try:
        chatter_publisher()
    except rospy.ROSInterruptException:
        pass",0
565,parameter execution code publisher publisher cpp,"#include <ros/ros.h>
#include <std_msgs/String.h>

class ParameterExecutionPublisher
{
public:
    ParameterExecutionPublisher() : nh_(""~"")
    {
        // Retrieve parameter values or use defaults if not set
        nh_.param<std::string>(""message"", message_, ""Hello, world!"");
        nh_.param<int>(""publish_rate"", publish_rate_, 1);

        // Initialize publisher
        pub_ = nh_.advertise<std_msgs::String>(""custom_message"", 10);

        // Create a ROS timer with the specified publish rate
        timer_ = nh_.createTimer(ros::Duration(1.0 / publish_rate_), &ParameterExecutionPublisher::publishMessage, this);
    }

    void publishMessage(const ros::TimerEvent&)
    {
        std_msgs::String msg;
        msg.data = message_;
        pub_.publish(msg);
    }

private:
    ros::NodeHandle nh_;
    ros::Publisher pub_;
    ros::Timer timer_;
    std::string message_;
    int publish_rate_;
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, ""parameter_execution_publisher"");
    ParameterExecutionPublisher publisher;

    ros::spin();

    return 0;
}",9.111750827238147
566,variable execution code publisher topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_callback(msg):
    rospy.loginfo(""Received: %s"", msg.data)

def chatter_publisher():
    pub = rospy.Publisher('chatter', String, queue_size=10)
    rospy.init_node('chatter_publisher', anonymous=True)
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        msg = ""Hello, World!""
        rospy.loginfo(""Publishing: %s"", msg)
        pub.publish(msg)
        rate.sleep()

if __name__ == '__main__':
    try:
        chatter_publisher()
    except rospy.ROSInterruptException:
        pass",0
567,variable execution code publisher planning chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterPublisher:
    def __init__(self):
        rospy.init_node('chatter_publisher', anonymous=True)
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        
    def run(self):
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            msg = ""Hello, ROS!""
            rospy.loginfo(msg)
            self.pub.publish(msg)
            rate.sleep()

if __name__ == '__main__':
    try:
        publisher = ChatterPublisher()
        publisher.run()
    except rospy.ROSInterruptException:
        pass",0
569,component execution code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterNode:
    def __init__(self):
        rospy.init_node('chatter_node', anonymous=True)
        self.chatter_pub = rospy.Publisher('chatter', String, queue_size=10)
        rospy.Subscriber('chatter', String, self.chatter_callback)

    def chatter_callback(self, msg):
        rospy.loginfo('Received: %s', msg.data)

    def publish_message(self, message):
        msg = String()
        msg.data = message
        self.chatter_pub.publish(msg)
        rospy.loginfo('Published: %s', message)

def main():
    chatter_node = ChatterNode()
    rate = rospy.Rate(1)  # 1 Hz
    while not rospy.is_shutdown():
        message = 'Hello, world!'
        chatter_node.publish_message(message)
        rate.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass",0
578,parameter execution publisher with theme chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterPublisher:
    def __init__(self):
        rospy.init_node('chatter_publisher', anonymous=True)
        
        # Retrieve the publishing rate from the ROS parameter server
        self.publishing_rate = rospy.get_param('~publishing_rate', 1)  # Default rate set to 1 Hz
        
        self.pub = rospy.Publisher('chatter', String, queue_size=10)
        
    def publish_message(self):
        rate = rospy.Rate(self.publishing_rate)
        
        while not rospy.is_shutdown():
            message = ""Hello, world!""
            self.pub.publish(message)
            rate.sleep()

if __name__ == '__main__':
    try:
        chatter_pub = ChatterPublisher()
        chatter_pub.publish_message()
    except rospy.ROSInterruptException:
        pass",0
580,parameter operation code publisher planning chatter,"#include <ros/ros.h>
#include <std_msgs/String.h>

int main(int argc, char **argv) {
    // Initialize the ROS node
    ros::init(argc, argv, ""chatter_publisher"");

    // Create a NodeHandle
    ros::NodeHandle nh;

    // Create a publisher object
    ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

    // Set the loop rate for publishing messages
    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        // Create a string message
        std_msgs::String msg;
        msg.data = ""Hello, world!"";

        // Publish the message
        chatter_pub.publish(msg);

        // Log the published message
        ROS_INFO(""Published: %s"", msg.data.c_str());

        // Spin once
        ros::spinOnce();

        // Sleep to maintain the loop rate
        loop_rate.sleep();
    }

    return 0;
}",8.90330172846021
581,parameter execution code cpp execution with topic chatter,"#include ""ros/ros.h""
#include ""std_msgs/String.h""

// Callback function to process incoming messages
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO(""I heard: [%s]"", msg->data.c_str());
}

int main(int argc, char **argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, ""listener"");
    ros::NodeHandle nh;

    // Subscribe to the ""chatter"" topic with a queue size of 1000 and register the callback function
    ros::Subscriber sub = nh.subscribe(""chatter"", 1000, chatterCallback);

    // Spin to keep the node running and invoke callbacks when new messages arrive
    ros::spin();

    return 0;
}",4.48187665735779
582,parameter navigation parameter ROS pub cpp with service chatter,"#include <ros/ros.h>
#include <std_msgs/String.h>
#include <my_robot_msgs/SetNavigationParam.h>

// ROS NodeHandle for communication with ROS system
ros::NodeHandle nh;

// Publisher for 'chatter' topic
ros::Publisher chatter_pub = nh.advertise<std_msgs::String>(""chatter"", 10);

// Service callback to set navigation parameter
bool setNavigationParamCallback(my_robot_msgs::SetNavigationParam::Request &req,
                                 my_robot_msgs::SetNavigationParam::Response &res) {
    nh.setParam(""navigation_parameter"", req.param_value);
    res.success = true;
    ROS_INFO(""Set navigation parameter to: %s"", req.param_value.c_str());
    return true;
}

int main(int argc, char** argv) {
    ros::init(argc, argv, ""parameter_navigation_node"");

    // Advertise the service for setting navigation parameter
    ros::ServiceServer service = nh.advertiseService(""set_navigation_param"", setNavigationParamCallback);

    // Define the loop rate for publishing messages
    ros::Rate loop_rate(1); // 1 Hz

    while (ros::ok()) {
        std_msgs::String msg;
        msg.data = ""Hello, ROS!"";

        chatter_pub.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}",0
583,parameter code publisher robot with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ParameterPublisherNode:
    def __init__(self):
        rospy.init_node('parameter_publisher_node', anonymous=True)
        self.rate = rospy.Rate(1)  # 1 Hz
        self.param1 = rospy.get_param('~param1', 'default_param1_value')
        self.param2 = rospy.get_param('~param2', 'default_param2_value')
        self.param3 = rospy.get_param('~param3', 'default_param3_value')
        self.publisher = rospy.Publisher('/chatter', String, queue_size=10)

    def publish_parameters(self):
        while not rospy.is_shutdown():
            message = ""param1: {}, param2: {}, param3: {}"".format(self.param1, self.param2, self.param3)
            self.publisher.publish(message)
            self.rate.sleep()

if __name__ == '__main__':
    try:
        node = ParameterPublisherNode()
        node.publish_parameters()
    except rospy.ROSInterruptException:
        pass",0
588,variable execution code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def chatter_callback(msg):
    rospy.loginfo(""Received: %s"", msg.data)

def chatter_listener():
    rospy.init_node('chatter_listener', anonymous=True)
    rospy.Subscriber(""/chatter"", String, chatter_callback)
    rospy.spin()

if __name__ == '__main__':
    try:
        chatter_listener()
    except rospy.ROSInterruptException:
        pass",0
595,factor code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

def callback(data):
    rospy.loginfo(rospy.get_caller_id() + ""I heard %s"", data.data)

def listener():
    rospy.init_node('listener', anonymous=True)
    rospy.Subscriber(""chatter"", String, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()",0
597,planning parameter execution code with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import String

class ChatterListenerNode:
    def __init__(self):
        rospy.init_node('chatter_listener_node', anonymous=True)

        # Get the parameter 'execution_mode' with a default value of 'mode1'
        self.execution_mode = rospy.get_param('~execution_mode', 'mode1')

        # Subscribe to the '/chatter' topic
        rospy.Subscriber('/chatter', String, self.chatter_callback)

    def chatter_callback(self, msg):
        rospy.loginfo(""Received: %s"", msg.data)

        if self.execution_mode == 'mode1':
            self.execute_mode1(msg.data)
        elif self.execution_mode == 'mode2':
            self.execute_mode2(msg.data)
        else:
            rospy.logwarn(""Invalid execution_mode. No action taken."")

    def execute_mode1(self, data):
        # Add code here for executing mode1
        rospy.loginfo(""Executing mode1 with data: %s"", data)

    def execute_mode2(self, data):
        # Add code here for executing mode2
        rospy.loginfo(""Executing mode2 with data: %s"", data)

if __name__ == '__main__':
    try:
        node = ChatterListenerNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass",0
598,parameter execution publisher message with topic chatter,"#!/usr/bin/env python

import rospy
from std_msgs.msg import Header
from my_custom_msg_package.msg import CustomMsg

def publisher():
    rospy.init_node('parameter_execution_publisher')
    pub = rospy.Publisher('/chatter', CustomMsg, queue_size=10)
    rate = rospy.Rate(1)  # 1 Hz

    while not rospy.is_shutdown():
        custom_msg = CustomMsg()
        custom_msg.parameter_id = 123
        custom_msg.parameter_name = 'param1'
        custom_msg.execution_time = 0.05
        rospy.loginfo(""Publishing CustomMsg: %s"", custom_msg)
        pub.publish(custom_msg)
        rate.sleep()

if __name__ == '__main__':
    try:
        publisher()
    except rospy.ROSInterruptException:
        pass",0
